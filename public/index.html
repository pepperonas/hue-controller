<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#2c2e3b">
    <link rel="apple-touch-icon" href="/static/apple-touch-icon.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hue Controller - Intelligente Lichtsteuerung</title>
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="manifest" href="/site.webmanifest">
    
    <style>
        :root {
            /* Farbschema */
            --background-dark: #2B2E3B;
            --background-darker: #252830;
            --card-background: #343845;
            --accent-blue: #688db1;
            --accent-green: #9cb68f;
            --accent-red: #e16162;
            --text-primary: #d1d5db;
            --text-secondary: #9ca3af;

            /* Schatten */
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.25);
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);

            /* Abstände */
            --spacing-1: 0.25rem;
            --spacing-2: 0.5rem;
            --spacing-3: 0.75rem;
            --spacing-4: 1rem;
            --spacing-6: 1.5rem;
            --spacing-8: 2rem;
            --spacing-12: 3rem;
            --spacing-16: 4rem;

            /* Rundungen */
            --radius-sm: 0.25rem;
            --radius: 0.5rem;
            --radius-lg: 0.75rem;
            --radius-xl: 1rem;

            /* Typografie */
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--background-dark);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            padding: var(--spacing-4);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--spacing-6);
            padding-bottom: 100px; /* Space for bottom nav */
        }

        .header {
            background-color: var(--background-darker);
            padding: var(--spacing-6);
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 100;
            text-align: center;
            margin-bottom: var(--spacing-6);
            border-radius: var(--radius-xl);
        }

        .header h1 {
            font-size: 1.875rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--spacing-2);
        }

        .power-display {
            background: rgba(156, 182, 143, 0.2);
            border: 1px solid rgba(156, 182, 143, 0.5);
            border-radius: var(--radius);
            padding: var(--spacing-4);
            margin-bottom: var(--spacing-4);
            text-align: center;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--background-darker);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: var(--spacing-3) 0 calc(var(--spacing-3) + env(safe-area-inset-bottom));
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: var(--spacing-2) var(--spacing-3);
            border-radius: var(--radius);
            min-width: 64px;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background: rgba(104, 141, 177, 0.2);
        }

        .nav-item.active .nav-icon {
            color: var(--accent-blue);
            transform: scale(1.1);
        }

        .nav-icon {
            font-size: 1.5rem;
            margin-bottom: var(--spacing-1);
            transition: all 0.3s ease;
        }

        .nav-label {
            font-size: 0.75rem;
            opacity: 0.8;
            font-weight: 500;
        }

        /* Hide old tabs on mobile */
        .tabs {
            display: none;
        }

        /* Desktop tabs for larger screens */
        @media (min-width: 768px) {
            .tabs {
                display: flex;
                border-bottom: 2px solid rgba(255, 255, 255, 0.1);
                margin-bottom: var(--spacing-6);
                overflow-x: auto;
                background: var(--card-background);
                border-radius: var(--radius) var(--radius) 0 0;
            }

            .tab {
                padding: var(--spacing-4) var(--spacing-6);
                background: none;
                border: none;
                color: var(--text-secondary);
                cursor: pointer;
                font-size: 1rem;
                font-weight: 500;
                white-space: nowrap;
                transition: all 0.3s ease;
                border-bottom: 3px solid transparent;
                flex: 1;
                min-width: 120px;
            }

            .tab:hover {
                color: var(--text-primary);
                background-color: rgba(255, 255, 255, 0.05);
            }

            .tab.active {
                color: var(--accent-blue);
                border-bottom-color: var(--accent-blue);
                background-color: rgba(104, 141, 177, 0.1);
            }

            .bottom-nav {
                display: none;
            }

            .container {
                padding-bottom: var(--spacing-6);
            }
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: var(--spacing-6);
            margin-bottom: var(--spacing-8);
        }

        .card {
            background-color: var(--card-background);
            border-radius: var(--radius-xl);
            padding: var(--spacing-6);
            margin-bottom: var(--spacing-6);
            box-shadow: var(--shadow);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }


        /* Chart Container Fixes */
        .card canvas {
            max-height: 400px;
            height: 400px !important;
            width: 100% !important;
        }

        #weekdayChart, #monthlyChart, #seasonalPieChart, #seasonalHourlyChart {
            max-height: 400px;
            height: 400px !important;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 500;
            margin-bottom: var(--spacing-3);
            color: var(--accent-blue);
        }

        /* Buttons */
        .btn {
            padding: var(--spacing-3) var(--spacing-6);
            border: none;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-2);
            width: 100%;
            margin: var(--spacing-1) 0;
        }

        .btn-primary {
            background-color: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            background-color: #5a7a9a;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-secondary {
            background-color: var(--accent-green);
            color: white;
        }

        .btn-secondary:hover {
            background-color: #8aa47d;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn.danger {
            background-color: var(--accent-red);
            color: white;
        }

        .btn.danger:hover {
            background-color: #d04f50;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn.warning {
            background-color: #fbbf24;
            color: #1a1a2e;
        }

        .btn.warning:hover {
            background-color: #f59e0b;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn.accent {
            background-color: #9C27B0;
            color: white;
        }

        .btn.accent:hover {
            background-color: #7B1FA2;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn.premium {
            background-color: #FFD700;
            color: #1a1a2e;
        }

        .btn.premium:hover {
            background-color: #FFA000;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-sm {
            padding: var(--spacing-2) var(--spacing-4);
            font-size: 0.875rem;
        }

        .btn-lg {
            padding: var(--spacing-4) var(--spacing-8);
            font-size: 1.125rem;
        }

        /* Formulare */
        .input-group {
            margin-bottom: var(--spacing-4);
        }

        .form-label {
            display: block;
            margin-bottom: var(--spacing-2);
            font-weight: 500;
            color: var(--text-primary);
        }

        .form-input {
            width: 100%;
            padding: var(--spacing-3);
            background-color: var(--background-darker);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(104, 141, 177, 0.1);
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .form-select {
            width: 100%;
            padding: var(--spacing-3);
            background-color: var(--background-darker);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
        }

        .form-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Slider */
        .slider-container {
            margin-bottom: var(--spacing-4);
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-2);
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: var(--radius);
            background: var(--background-darker);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            background: #5a7a9a;
            transform: scale(1.1);
            box-shadow: var(--shadow);
        }

        .slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-sm);
        }

        .color-picker {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            background: transparent;
        }

        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: var(--radius);
            margin: var(--spacing-2) 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: inline-block;
            cursor: pointer;
        }

        .global-controls {
            background: rgba(225, 97, 98, 0.2);
            border: 1px solid rgba(225, 97, 98, 0.5);
            border-radius: var(--radius-xl);
            padding: var(--spacing-6);
            margin-bottom: var(--spacing-6);
        }

        .global-controls h3 {
            margin-bottom: var(--spacing-4);
            color: var(--accent-red);
        }

        /* Statistics Cards */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
        }

        .status-item {
            background: var(--background-darker);
            padding: var(--spacing-4);
            border-radius: var(--radius);
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .status-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-blue);
        }

        .status-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: var(--spacing-1);
        }

        /* Erweiterte Status-Item Kategorien */
        .status-item.highlight {
            background: linear-gradient(135deg, rgba(104, 141, 177, 0.3) 0%, rgba(104, 141, 177, 0.1) 100%);
            border: 1px solid var(--accent-blue);
            box-shadow: 0 0 15px rgba(104, 141, 177, 0.3);
        }

        .status-item.highlight .status-value {
            color: var(--accent-blue);
            font-size: 2.2rem;
            text-shadow: 0 0 10px rgba(104, 141, 177, 0.5);
        }

        .status-item.eco {
            background: linear-gradient(135deg, rgba(156, 182, 143, 0.3) 0%, rgba(156, 182, 143, 0.1) 100%);
            border: 1px solid var(--accent-green);
        }

        .status-item.eco .status-value {
            color: var(--accent-green);
        }

        .status-item.fun {
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.3) 0%, rgba(255, 193, 7, 0.1) 100%);
            border: 1px solid #fbbf24;
        }

        .status-item.fun .status-value {
            color: #fbbf24;
        }

        .effect-controls {
            display: flex;
            gap: var(--spacing-3);
            flex-wrap: wrap;
        }

        .effect-controls .btn {
            flex: 1;
            min-width: 120px;
        }

        /* Elegante intuitive Button-Styles */
        .btn-on {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: #f7fafc;
            border: 1px solid #4a5568;
            box-shadow: 0 2px 8px rgba(74, 85, 104, 0.2);
        }

        .btn-on:hover {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(74, 85, 104, 0.3);
        }

        .btn-off {
            background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
            color: #f7fafc;
            border: 1px solid #718096;
            box-shadow: 0 2px 8px rgba(113, 128, 150, 0.2);
        }

        .btn-off:hover {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(113, 128, 150, 0.3);
        }

        .btn-disabled {
            background: #7f8c8d;
            color: #bdc3c7;
            border: 1px solid #7f8c8d;
            cursor: not-allowed;
        }

        .btn-disabled:hover {
            background: #7f8c8d;
            transform: none;
            box-shadow: none;
        }

        /* Unreachable Card Styles */
        .card.unreachable {
            opacity: 0.5;
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            border: 1px solid #7f8c8d;
            filter: grayscale(0.8);
        }

        /* Button Configuration Styles */
        .button-config-form {
            background: rgba(52, 56, 69, 0.7);
            border-radius: var(--radius-lg);
            padding: var(--spacing-6);
            margin-top: var(--spacing-4);
            border: 1px solid rgba(156, 182, 143, 0.3);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-4);
            margin-bottom: var(--spacing-6);
        }

        .form-field {
            display: flex;
            flex-direction: column;
        }

        .form-field label {
            font-weight: 500;
            margin-bottom: var(--spacing-2);
            color: var(--accent-blue);
        }

        .form-field input,
        .form-field select {
            padding: var(--spacing-3);
            border: 1px solid rgba(156, 182, 143, 0.3);
            border-radius: var(--radius);
            background-color: var(--background-darker);
            color: var(--text-primary);
            font-size: 1rem;
        }

        .form-field input:focus,
        .form-field select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px rgba(104, 141, 177, 0.1);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            margin-bottom: var(--spacing-4);
            padding: var(--spacing-3);
            border-radius: var(--radius);
            background: rgba(52, 56, 69, 0.5);
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-red);
        }

        .status-dot.online {
            background: var(--accent-green);
        }

        .button-configs-container {
            display: grid;
            gap: var(--spacing-4);
        }

        .button-config-item {
            background: rgba(52, 56, 69, 0.5);
            border-radius: var(--radius-lg);
            padding: var(--spacing-4);
            border: 1px solid rgba(156, 182, 143, 0.2);
            display: grid;
            grid-template-columns: auto 1fr auto;
            align-items: center;
            gap: var(--spacing-4);
        }

        .button-config-info {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-1);
        }

        .button-config-title {
            font-weight: 500;
            color: var(--text-primary);
        }

        .button-config-details {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .button-config-actions {
            display: flex;
            gap: var(--spacing-2);
        }

        .small-btn {
            padding: var(--spacing-2) var(--spacing-3);
            border: none;
            border-radius: var(--radius);
            background: var(--accent-blue);
            color: white;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.2s ease;
        }

        .small-btn:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .action-btn {
            padding: var(--spacing-3) var(--spacing-6);
            border: none;
            border-radius: var(--radius-lg);
            background: linear-gradient(135deg, var(--accent-blue) 0%, #5a7a9a 100%);
            color: white;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-2);
            width: 100%;
            margin-top: var(--spacing-4);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            background: linear-gradient(135deg, #5a7a9a 0%, var(--accent-blue) 100%);
        }

        .action-btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow);
        }

        .button-logs-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--spacing-4);
        }

        .logs-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(156, 182, 143, 0.2);
            border-radius: var(--radius);
            background: rgba(52, 56, 69, 0.3);
        }

        .log-entry {
            padding: var(--spacing-3);
            border-bottom: 1px solid rgba(156, 182, 143, 0.1);
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            gap: var(--spacing-3);
            align-items: center;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-timestamp {
            font-size: 0.875rem;
            color: var(--text-secondary);
            font-family: monospace;
        }

        .log-details {
            color: var(--text-primary);
        }

        .log-status {
            padding: var(--spacing-1) var(--spacing-2);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 500;
        }

        .log-status.success {
            background: rgba(156, 182, 143, 0.2);
            color: var(--accent-green);
        }

        .log-status.error {
            background: rgba(225, 97, 98, 0.2);
            color: var(--accent-red);
        }

        .loading-spinner {
            text-align: center;
            padding: var(--spacing-6);
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            .form-grid {
                grid-template-columns: 1fr;
            }
            
            .button-config-item {
                grid-template-columns: 1fr;
                text-align: center;
            }
            
            .button-logs-header {
                flex-direction: column;
                gap: var(--spacing-2);
            }
            
            .log-entry {
                grid-template-columns: 1fr;
                text-align: center;
                gap: var(--spacing-2);
            }
        }

        .unreachable-label {
            font-size: 0.75rem;
            color: #e74c3c;
            font-weight: bold;
            margin-left: 8px;
            background: rgba(231, 76, 60, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* Light On Glow Effect - Will be dynamically styled with actual light color */
        .card.light-on {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3), 
                        0 4px 6px -1px rgba(0, 0, 0, 0.3),
                        0 2px 4px -1px rgba(0, 0, 0, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.4);
            /* Animation removed - will be handled dynamically */
        }

        /* Color Quick Selection */
        .color-quick-selection {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .color-btn {
            width: 32px;
            height: 32px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .color-btn:hover {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .color-btn:active {
            transform: scale(0.95);
        }

        .color-btn.active {
            border-color: #FFD700;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            transform: scale(1.1);
        }

        .color-palette {
            padding: 10px;
        }

        .color-category {
            margin-bottom: 15px;
        }

        .color-category h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }

        .color-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-row .color-btn {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            color: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .color-row .color-btn:hover {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .strobe-speed-select {
            width: 100%;
            margin-top: 4px;
            padding: 6px 8px;
            border-radius: 4px;
            background: rgba(52, 56, 69, 0.8);
            color: #d1d5db;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .strobe-speed-select:hover {
            border-color: rgba(255, 255, 255, 0.4);
            background: rgba(52, 56, 69, 0.9);
        }

        .strobe-speed-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(104, 141, 177, 0.2);
        }

        .strobe-speed-select option {
            background: var(--card-background);
            color: var(--text-primary);
            padding: 4px 8px;
        }

        .strobe-speed-control {
            margin-bottom: 8px;
        }

        .strobe-speed-control label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            display: block;
            margin-bottom: 4px;
        }

        .btn-active {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E) !important;
            color: white !important;
            border-color: #FF6B6B !important;
            box-shadow: 0 0 15px rgba(255, 107, 107, 0.5) !important;
            animation: pulse 2s infinite !important;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(255, 107, 107, 0.5); }
            50% { box-shadow: 0 0 25px rgba(255, 107, 107, 0.8); }
            100% { box-shadow: 0 0 15px rgba(255, 107, 107, 0.5); }
        }

        .strobe-active {
            border: 2px solid #ff6b6b !important;
            animation: strobe-glow 2s infinite !important;
        }

        @keyframes strobe-glow {
            0% { 
                box-shadow: 0 0 5px rgba(255, 107, 107, 0.3), 0 0 20px rgba(255, 107, 107, 0.2), 0 0 30px rgba(255, 107, 107, 0.1);
                border-color: rgba(255, 107, 107, 0.6);
            }
            50% { 
                box-shadow: 0 0 10px rgba(255, 107, 107, 0.6), 0 0 40px rgba(255, 107, 107, 0.4), 0 0 60px rgba(255, 107, 107, 0.2);
                border-color: rgba(255, 107, 107, 1);
            }
            100% { 
                box-shadow: 0 0 5px rgba(255, 107, 107, 0.3), 0 0 20px rgba(255, 107, 107, 0.2), 0 0 30px rgba(255, 107, 107, 0.1);
                border-color: rgba(255, 107, 107, 0.6);
            }
        }

        .timer-list, .effect-list {
            max-height: 200px;
            overflow-y: auto;
            background: var(--background-darker);
            border-radius: var(--radius);
            padding: var(--spacing-3);
            margin-top: var(--spacing-3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .timer-item, .effect-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-2);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .timer-item:last-child, .effect-item:last-child {
            border-bottom: none;
        }

        .scene-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: var(--spacing-3);
        }

        .scene-btn {
            padding: var(--spacing-4) var(--spacing-3);
            background: rgba(156, 39, 176, 0.2);
            border: 1px solid rgba(156, 39, 176, 0.5);
            border-radius: var(--radius);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 0.9rem;
        }

        .scene-btn:hover {
            background: rgba(156, 39, 176, 0.4);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        /* Debug Styles */
        .debug-log-container {
            margin-top: var(--spacing-4);
        }

        .debug-log {
            height: 300px;
            overflow-y: auto;
            background: var(--background-darker);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius);
            padding: var(--spacing-3);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }

        .debug-entry {
            display: flex;
            gap: var(--spacing-3);
            padding: var(--spacing-1) 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .debug-entry:last-child {
            border-bottom: none;
        }

        .debug-time {
            color: var(--text-secondary);
            min-width: 60px;
            font-size: 0.8rem;
        }

        .debug-type {
            min-width: 60px;
            font-weight: bold;
            padding: var(--spacing-1) var(--spacing-2);
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
        }

        .debug-type.info {
            background: rgba(104, 141, 177, 0.3);
            color: var(--accent-blue);
        }

        .debug-type.success {
            background: rgba(156, 182, 143, 0.3);
            color: var(--accent-green);
        }

        .debug-type.warning {
            background: rgba(251, 191, 36, 0.3);
            color: #fbbf24;
        }

        .debug-type.error {
            background: rgba(225, 97, 98, 0.3);
            color: var(--accent-red);
        }

        .debug-message {
            flex: 1;
            word-break: break-all;
        }

        .debug-controls {
            display: flex;
            gap: var(--spacing-3);
            align-items: center;
            margin-bottom: var(--spacing-4);
            flex-wrap: wrap;
        }

        .debug-controls label {
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            font-size: 0.9rem;
        }

        .debug-controls select {
            background: var(--background-darker);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            padding: var(--spacing-1) var(--spacing-2);
        }

        .debug-test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-3);
            margin-top: var(--spacing-3);
        }

        /* Ultra-Strobo Styles */
        .ultra-strobo-section {
            border: 2px solid var(--accent-red);
            border-radius: var(--radius-xl);
            background: rgba(225, 97, 98, 0.1);
            padding: var(--spacing-6);
            margin-top: var(--spacing-6);
        }

        .warning-box {
            background: rgba(251, 191, 36, 0.2);
            border: 2px solid #fbbf24;
            border-radius: var(--radius);
            padding: var(--spacing-4);
            margin-bottom: var(--spacing-6);
            text-align: center;
            font-weight: bold;
            color: #fbbf24;
            animation: warning-pulse 2s infinite;
        }

        @keyframes warning-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .ultra-strobo-presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--spacing-3);
            margin-bottom: var(--spacing-6);
        }

        .ultra-btn {
            padding: var(--spacing-3);
            font-weight: bold;
            border: 2px solid var(--accent-red);
            animation: danger-glow 1.5s infinite;
            border-radius: var(--radius);
        }

        @keyframes danger-glow {
            0%, 100% { box-shadow: 0 0 5px rgba(225, 97, 98, 0.5); }
            50% { box-shadow: 0 0 20px rgba(225, 97, 98, 0.8); }
        }
        
        /* Individual Lamp Selection Styles */
        .lamp-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: var(--spacing-1);
        }
        
        .lamp-selection-grid label:hover {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius);
        }
        
        /* Checkbox Styling */
        .lamp-checkbox, .form-checkbox, input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: var(--radius);
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .lamp-checkbox:hover, .form-checkbox:hover, input[type="checkbox"]:hover {
            border-color: var(--accent-blue);
            background: rgba(104, 141, 177, 0.1);
            transform: scale(1.05);
        }
        
        .lamp-checkbox:checked, .form-checkbox:checked, input[type="checkbox"]:checked {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px rgba(104, 141, 177, 0.3);
        }
        
        .lamp-checkbox:checked::after, .form-checkbox:checked::after, input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        .lamp-checkbox:focus, .form-checkbox:focus, input[type="checkbox"]:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(104, 141, 177, 0.2);
        }

        .ultra-slider {
            background: linear-gradient(90deg, #fbbf24 0%, var(--accent-red) 50%, #dc2626 100%);
        }

        .emergency-controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: var(--spacing-3);
            margin-top: var(--spacing-4);
        }

        /* Strobo Color Selection Styles */
        .color-selection-section {
            margin-top: var(--spacing-6);
            padding: var(--spacing-4);
            background: var(--card-background);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .color-selection-section h5 {
            margin-bottom: var(--spacing-3);
            color: var(--accent-blue);
            font-size: 1.1rem;
        }

        .strobo-color-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--spacing-2);
            margin-bottom: var(--spacing-3);
        }

        .color-preset-btn {
            padding: var(--spacing-2) var(--spacing-3);
            border: 2px solid transparent;
            border-radius: var(--radius);
            cursor: pointer;
            font-weight: bold;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background-size: cover;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }

        .color-preset-btn:hover {
            transform: scale(1.05);
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px rgba(104, 141, 177, 0.5);
        }

        .color-preset-btn.active {
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px rgba(104, 141, 177, 0.8);
            transform: scale(1.1);
        }

        .color-values {
            text-align: center;
            padding: var(--spacing-2);
            background: var(--background-darker);
            border-radius: var(--radius);
            font-size: 0.9rem;
        }

        /* === ERWEITERTE FARBPALETTEN STYLING === */
        .color-palette-category {
            margin-bottom: var(--spacing-4);
        }

        .color-palette-category h6 {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-2);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .color-grid-4x4 {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-2);
            margin-bottom: var(--spacing-3);
        }

        /* Responsive Grid für mobile Geräte */
        @media (max-width: 768px) {
            .color-grid-4x4 {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-3);
            }
        }

        @media (max-width: 480px) {
            .color-grid-4x4 {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-2);
            }
        }

        /* Optimierte Color Preset Buttons für 4x4 Grid */
        .color-grid-4x4 .color-preset-btn {
            padding: var(--spacing-3) var(--spacing-2);
            font-size: 0.8rem;
            text-align: center;
            min-height: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .color-grid-4x4 .color-preset-btn:hover {
            transform: scale(1.03);
        }

        .color-grid-4x4 .color-preset-btn.active {
            transform: scale(1.06);
        }

        /* Mobile Optimierungen */
        @media (max-width: 768px) {
            .color-grid-4x4 .color-preset-btn {
                min-height: 60px;
                font-size: 0.9rem;
                padding: var(--spacing-3);
            }
        }

        /* === KLAPPBARE CARDS === */
        .collapsible-card {
            margin-bottom: var(--spacing-4);
        }

        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: var(--spacing-3);
            background: var(--card-background);
            border-radius: var(--radius);
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .collapsible-header:hover {
            background: rgba(255, 255, 255, 0.02);
            border-color: rgba(255, 255, 255, 0.2);
        }

        .collapsible-header h3 {
            margin: 0;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .collapse-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            color: var(--text-secondary);
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            background: var(--background-darker);
            border-radius: 0 0 var(--radius) var(--radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: none;
        }

        .collapsible-content.expanded {
            padding: var(--spacing-4);
            max-height: none;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            padding: 0 var(--spacing-4);
        }

        /* Spezielle Anpassungen für card-title in collapsible */
        .card-title.collapsible-header {
            margin-bottom: 0;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .duration-info {
            text-align: center;
            margin-top: var(--spacing-2);
            color: var(--text-secondary);
        }

        /* Guide Tab Styles */
        .guide-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .guide-nav {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-3);
            margin-bottom: var(--spacing-6);
            padding: var(--spacing-4);
            background: var(--background-darker);
            border-radius: var(--radius-xl);
        }

        .guide-nav-btn {
            padding: var(--spacing-2) var(--spacing-3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius);
            background: var(--card-background);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            text-align: center;
        }

        .guide-nav-btn:hover {
            background: rgba(104, 141, 177, 0.2);
            border-color: var(--accent-blue);
        }

        .guide-nav-btn.active {
            background: rgba(104, 141, 177, 0.3);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .guide-section {
            display: none;
        }

        .guide-section.active {
            display: block;
        }

        .guide-content {
            line-height: 1.6;
        }

        .guide-content h3 {
            color: var(--accent-blue);
            margin: var(--spacing-6) 0 var(--spacing-3) 0;
            border-left: 3px solid var(--accent-blue);
            padding-left: var(--spacing-3);
        }

        .guide-content ul, .guide-content ol {
            margin: var(--spacing-3) 0 var(--spacing-6) var(--spacing-6);
        }

        .guide-content li {
            margin: var(--spacing-2) 0;
        }

        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--spacing-4);
            margin: var(--spacing-6) 0;
        }

        .quick-action {
            display: flex;
            align-items: center;
            padding: var(--spacing-4);
            background: var(--card-background);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .quick-icon {
            font-size: 2rem;
            margin-right: var(--spacing-4);
        }

        .quick-text {
            flex: 1;
        }

        .shortcut-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-3);
            margin: var(--spacing-4) 0;
        }

        .shortcut-item {
            padding: var(--spacing-3);
            background: rgba(104, 141, 177, 0.1);
            border: 1px solid rgba(104, 141, 177, 0.3);
            border-radius: var(--radius);
            text-align: center;
            font-size: 0.9rem;
        }

        .effects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-4);
            margin: var(--spacing-6) 0;
        }

        .effect-card {
            padding: var(--spacing-4);
            background: var(--card-background);
            border-radius: var(--radius-xl);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .effect-name {
            font-weight: bold;
            color: var(--accent-blue);
            margin-bottom: var(--spacing-2);
        }

        .effect-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .color-demo {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--spacing-4);
            margin: var(--spacing-4) 0;
        }

        .color-method {
            padding: var(--spacing-3);
            background: var(--card-background);
            border-radius: var(--radius);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .problem-solution {
            margin: var(--spacing-6) 0;
            padding: var(--spacing-4);
            background: var(--card-background);
            border-radius: var(--radius-xl);
            border-left: 4px solid var(--accent-red);
        }

        .problem {
            font-weight: bold;
            color: var(--accent-red);
            margin-bottom: var(--spacing-3);
        }

        .solution {
            color: var(--text-primary);
            line-height: 1.5;
        }

        .support-info {
            padding: var(--spacing-4);
            background: var(--background-darker);
            border-radius: var(--radius);
            font-family: monospace;
            font-size: 0.9rem;
            margin: var(--spacing-4) 0;
        }

        .power-chart {
            background: var(--card-background);
            border-radius: var(--radius);
            padding: var(--spacing-6);
            margin-top: var(--spacing-6);
            min-height: 300px;
            max-height: 450px;
            overflow: hidden;
            position: relative;
        }
        
        .power-chart canvas {
            max-height: 350px !important;
            height: 350px !important;
        }

        /* Neue Klassen für erweiterte Funktionen */
        .quick-scenes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--spacing-3);
            margin-bottom: var(--spacing-6);
        }

        .quick-scene {
            background: var(--card-background);
            border-radius: var(--radius-xl);
            padding: var(--spacing-4);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .quick-scene:hover {
            transform: translateY(-2px);
            background: var(--card-background);
            box-shadow: var(--shadow-lg);
        }

        .quick-scene .icon {
            font-size: 2rem;
            margin-bottom: 8px;
            display: block;
        }

        .quick-scene .name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .advanced-effects {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .effect-card {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.2) 0%, rgba(103, 58, 183, 0.2) 100%);
            border: 1px solid rgba(156, 39, 176, 0.3);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .effect-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(156, 39, 176, 0.3);
        }

        .effect-card .icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
            display: block;
        }

        .effect-card .name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .effect-card .description {
            font-size: 0.85rem;
            opacity: 0.8;
        }

        .color-palette {
            display: flex;
            gap: 8px;
            margin: 12px 0;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.2);
            border-color: rgba(255, 255, 255, 0.6);
        }

        .color-swatch.active {
            border-color: #fff;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 8px 16px;
            margin-bottom: 8px;
        }

        .control-group h4 {
            margin-bottom: 12px;
            color: #E0E0E0;
            font-size: 1rem;
        }

        .slider-container {
            position: relative;
            margin: 16px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .slider-value {
            background: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 8px;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
        }

        .floating-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }

        .floating-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FF6B6B 0%, #FF5252 100%);
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .floating-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        .pulse-animation {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .glow-effect {
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 20px rgba(76, 175, 80, 0.4); }
            to { box-shadow: 0 0 40px rgba(76, 175, 80, 0.8); }
        }

        /* Message */
        .message {
            position: fixed;
            bottom: var(--spacing-6);
            right: var(--spacing-6);
            padding: var(--spacing-4) var(--spacing-6);
            border-radius: var(--radius);
            color: white;
            font-weight: 500;
            box-shadow: var(--shadow-lg);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            z-index: 1000;
            max-width: 400px;
        }

        .message.show {
            opacity: 1;
            transform: translateY(0);
        }

        .message.success {
            background-color: #22c55e;
            color: #ffffff;
        }

        .message.error {
            background-color: #ef4444;
            color: #ffffff;
        }

        .message.info {
            background-color: #3b82f6;
            color: #ffffff;
        }

        .message.warning {
            background-color: #f59e0b;
            color: #ffffff;
        }

        .error {
            background: rgba(225, 97, 98, 0.2);
            color: var(--accent-red);
            padding: var(--spacing-3);
            border-radius: var(--radius);
            margin-bottom: var(--spacing-6);
            border: 1px solid rgba(225, 97, 98, 0.5);
        }

        .success {
            background: rgba(156, 182, 143, 0.2);
            color: var(--accent-green);
            padding: var(--spacing-3);
            border-radius: var(--radius);
            margin-bottom: var(--spacing-6);
            border: 1px solid rgba(156, 182, 143, 0.5);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: var(--spacing-4);
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .controls-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                margin-bottom: var(--spacing-4);
            }

            .tab {
                padding: var(--spacing-3) var(--spacing-4);
                font-size: 0.875rem;
                min-width: 100px;
            }
            
            .effect-controls {
                flex-direction: column;
            }

            .quick-scenes {
                grid-template-columns: repeat(3, 1fr);
                gap: var(--spacing-2);
            }

            .quick-scene {
                padding: var(--spacing-3);
            }

            .quick-scene .icon {
                font-size: 1.5rem;
            }

            .advanced-effects {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-3);
            }

            .effect-card {
                padding: var(--spacing-4);
            }

            .effect-card .icon {
                font-size: 2rem;
            }

            .floating-controls {
                bottom: var(--spacing-4);
                right: var(--spacing-4);
                gap: var(--spacing-2);
            }

            .floating-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            .color-palette {
                justify-content: center;
            }

            .color-swatch {
                width: 36px;
                height: 36px;
            }

            /* Touch-friendly buttons */
            .btn {
                padding: var(--spacing-4) var(--spacing-6);
                font-size: 1.1rem;
                margin: var(--spacing-2) 0;
            }

            .slider {
                height: 8px;
            }

            .slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.5rem;
            }

            .quick-scenes {
                grid-template-columns: repeat(2, 1fr);
            }

            .advanced-effects {
                grid-template-columns: 1fr;
            }

            .tabs {
                font-size: 0.8rem;
            }

            .tab {
                min-width: 80px;
                padding: var(--spacing-2) var(--spacing-3);
            }

            .card {
                padding: var(--spacing-4);
            }

            .floating-btn {
                width: 45px;
                height: 45px;
                font-size: 1rem;
            }
        }

        /* Touch gestures */
        .swipe-gesture {
            touch-action: pan-y;
        }

        .card.swipe-left {
            transform: translateX(-20px);
            opacity: 0.8;
        }

        .card.swipe-right {
            transform: translateX(20px);
            opacity: 0.8;
        }

        /* Mood Scenes Styles */
        .mood-category {
            margin-bottom: var(--spacing-6);
        }

        .mood-category-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: var(--spacing-3);
            opacity: 0.9;
            display: flex;
            align-items: center;
            gap: var(--spacing-2);
            color: var(--accent-blue);
        }

        .mood-scenes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: var(--spacing-3);
        }

        .mood-scene-card {
            background: var(--card-background);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-xl);
            padding: var(--spacing-4);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .mood-scene-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent-blue);
            background: var(--card-background);
            box-shadow: var(--shadow-lg);
        }

        .mood-scene-icon {
            font-size: 2.5rem;
            margin-bottom: var(--spacing-2);
            display: block;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        .mood-scene-name {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: var(--spacing-1);
        }

        .mood-scene-category {
            font-size: 0.75rem;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Audio Sync Status */
        .audio-sync-active {
            animation: audioSync 2s ease-in-out infinite;
        }

        @keyframes audioSync {
            0% { border-color: rgba(78, 205, 196, 0.3); }
            50% { border-color: rgba(78, 205, 196, 0.8); }
            100% { border-color: rgba(78, 205, 196, 0.3); }
        }

        /* === SMART ERROR HANDLING STYLES === */
        
        .system-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            position: relative;
            background: rgba(26, 26, 46, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 600px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .modal-header {
            padding: 20px 24px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            margin: 0;
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .modal-header button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 1.5rem;
            cursor: pointer;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .modal-header button:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #FFFFFF;
        }
        
        .modal-body {
            padding: 20px 24px;
            max-height: 60vh;
            overflow-y: auto;
        }
        
        .modal-footer {
            padding: 16px 24px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: right;
        }
        
        .modal-footer button {
            background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .modal-footer button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(68, 160, 141, 0.4);
        }
        
        /* Health Status */
        .health-status {
            padding: 16px;
            border-radius: 12px;
            margin-bottom: 16px;
        }
        
        .health-status.healthy {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .health-status.degraded {
            background: rgba(255, 152, 0, 0.1);
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        .health-status.critical {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .health-checks {
            margin: 12px 0;
        }
        
        .health-check {
            padding: 8px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        
        .recommendations {
            margin-top: 16px;
        }
        
        .recommendations h5 {
            margin-bottom: 8px;
            color: #4ECDC4;
        }
        
        .recommendations ul {
            margin-left: 20px;
        }
        
        .recommendations li {
            margin-bottom: 4px;
            line-height: 1.4;
        }
        
        /* Smart Error Display */
        .smart-error {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid rgba(244, 67, 54, 0.3);
            border-radius: 12px;
            padding: 20px;
        }
        
        .smart-error h4 {
            color: #FF6B6B;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }
        
        .error-message {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(244, 67, 54, 0.1);
            border-radius: 8px;
            font-weight: 500;
        }
        
        .error-solutions {
            margin: 16px 0;
        }
        
        .error-solutions h5 {
            color: #4ECDC4;
            margin-bottom: 8px;
        }
        
        .error-solutions ul {
            margin-left: 20px;
        }
        
        .error-solutions li {
            margin-bottom: 6px;
            line-height: 1.4;
        }
        
        .error-actions {
            display: flex;
            gap: 12px;
            margin: 16px 0;
            flex-wrap: wrap;
        }
        
        .error-actions .btn {
            font-size: 0.9rem;
            padding: 8px 16px;
        }
        
        .technical-details {
            margin-top: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
        }
        
        .technical-details summary {
            cursor: pointer;
            font-weight: 600;
            color: #4ECDC4;
        }
        
        .technical-details p {
            margin: 8px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        /* Diagnosis Result */
        .diagnosis-result {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            border-radius: 12px;
            padding: 20px;
        }
        
        .diagnosis-result h4 {
            color: #2196F3;
            margin-bottom: 16px;
        }
        
        .diagnosis-tests {
            margin: 16px 0;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 16px;
        }
        
        .test-result {
            margin-bottom: 8px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        
        .test-result:last-child {
            border-bottom: none;
        }
        
        .test-result strong {
            color: #4ECDC4;
        }
        
        .solutions h5 {
            color: #4ECDC4;
            margin: 16px 0 8px;
        }
        
        /* Responsive Modal */
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                max-width: none;
                margin: 20px;
            }
            
            .modal-body {
                max-height: 70vh;
            }
            
            .error-actions {
                flex-direction: column;
            }
            
            .error-actions .btn {
                width: 100%;
                text-align: center;
            }
        }

        /* === POWER TAB STYLES === */
        
        /* Power view tab styling for all screen sizes */
        #power-tab .tabs .tab {
            background: var(--card-background);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            transition: all 0.3s ease;
            border-radius: var(--radius);
            cursor: pointer;
        }
        
        #power-tab .tabs .tab:hover {
            background: rgba(104, 141, 177, 0.1);
            border-color: var(--accent-blue);
            transform: translateY(-1px);
        }
        
        #power-tab .tabs .tab.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
            box-shadow: 0 2px 8px rgba(104, 141, 177, 0.3);
        }

        /* === MOBILE OPTIMIZATIONS === */
        
        /* Tablet and smaller (768px and below) */
        @media (max-width: 768px) {
            .container {
                padding: var(--spacing-4);
                padding-bottom: 80px;
            }
            
            .header {
                padding: var(--spacing-4);
                margin-bottom: var(--spacing-4);
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .tabs {
                overflow-x: auto;
                overflow-y: hidden;
                white-space: nowrap;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
                padding-bottom: var(--spacing-2);
            }
            
            /* Power tabs should not scroll but wrap */
            #power-tab .tabs {
                overflow-x: visible;
                white-space: normal;
                display: flex;
                flex-wrap: wrap;
                gap: var(--spacing-1);
            }
            
            .tabs::-webkit-scrollbar {
                display: none;
            }
            
            .tab {
                flex-shrink: 0;
                min-width: 100px;
                font-size: 0.875rem;
                padding: var(--spacing-2) var(--spacing-3);
            }
            
            .quick-scenes {
                grid-template-columns: repeat(3, 1fr);
                gap: var(--spacing-2);
            }
            
            .quick-scene {
                padding: var(--spacing-3);
            }
            
            .quick-scene .icon {
                font-size: 1.5rem;
            }
            
            .quick-scene .name {
                font-size: 0.8rem;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-3);
            }
            
            .mood-scenes-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: var(--spacing-2);
            }
            
            .floating-controls {
                bottom: 15px;
                right: 15px;
            }
            
            .floating-btn {
                width: 50px;
                height: 50px;
                font-size: 1.25rem;
            }
            
            /* Power view tabs on tablet */
            #power-tab .tabs .tab {
                min-width: auto;
                flex: 1;
                font-size: 0.8rem;
                padding: var(--spacing-2);
                text-align: center;
                background: var(--card-background);
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: var(--text-primary);
                transition: all 0.3s ease;
            }
            
            #power-tab .tabs .tab:hover {
                background: rgba(104, 141, 177, 0.1);
                border-color: var(--accent-blue);
                transform: translateY(-1px);
            }
            
            #power-tab .tabs .tab.active {
                background: var(--accent-blue);
                border-color: var(--accent-blue);
                color: white;
                box-shadow: 0 2px 8px rgba(104, 141, 177, 0.3);
            }
        }
        
        /* Mobile phones (480px and below) */
        @media (max-width: 480px) {
            body {
                padding: var(--spacing-2);
            }
            
            .container {
                padding: var(--spacing-2);
                padding-bottom: 70px;
            }
            
            .header {
                padding: var(--spacing-3);
                margin-bottom: var(--spacing-3);
            }
            
            .header h1 {
                font-size: 1.25rem;
                margin-bottom: var(--spacing-1);
            }
            
            .power-display {
                padding: var(--spacing-2);
                margin-bottom: var(--spacing-2);
                font-size: 0.875rem;
            }
            
            .quick-scenes {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-2);
            }
            
            .quick-scene {
                padding: var(--spacing-2);
            }
            
            .quick-scene .icon {
                font-size: 1.25rem;
                margin-bottom: var(--spacing-1);
            }
            
            .quick-scene .name {
                font-size: 0.75rem;
            }
            
            .global-controls h3 {
                font-size: 1rem;
                margin-bottom: var(--spacing-2);
            }
            
            .effect-controls {
                gap: var(--spacing-2);
            }
            
            .btn {
                padding: var(--spacing-2) var(--spacing-3);
                font-size: 0.875rem;
                min-height: 44px; /* Touch-friendly minimum */
            }
            
            .tab {
                min-width: 80px;
                padding: var(--spacing-2);
                font-size: 0.8rem;
                min-height: 44px;
            }
            
            /* Power view tabs need special treatment on mobile */
            #power-tab .tabs .tab {
                min-width: auto;
                flex: 1;
                font-size: 0.75rem;
                padding: var(--spacing-2) var(--spacing-1);
                text-align: center;
                background: var(--card-background);
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: var(--text-primary);
                transition: all 0.3s ease;
                border-radius: var(--radius);
            }
            
            #power-tab .tabs .tab:hover {
                background: rgba(104, 141, 177, 0.1);
                border-color: var(--accent-blue);
                transform: translateY(-1px);
            }
            
            #power-tab .tabs .tab.active {
                background: var(--accent-blue);
                border-color: var(--accent-blue);
                color: white;
                box-shadow: 0 2px 8px rgba(104, 141, 177, 0.3);
            }
            
            .card {
                padding: var(--spacing-3);
                margin-bottom: var(--spacing-3);
            }
            
            .card-title {
                font-size: 1rem;
                margin-bottom: var(--spacing-2);
            }
            
            .control-group {
                margin-bottom: var(--spacing-3);
            }
            
            .input-group {
                margin-bottom: var(--spacing-2);
            }
            
            .slider-container {
                margin-bottom: var(--spacing-2);
            }
            
            .lamp-selection-grid {
                grid-template-columns: 1fr;
                max-height: 150px;
            }
            
            .floating-controls {
                bottom: 10px;
                right: 10px;
                gap: 8px;
            }
            
            .floating-btn {
                width: 45px;
                height: 45px;
                font-size: 1.1rem;
            }
            
            .message {
                bottom: var(--spacing-3);
                right: var(--spacing-3);
                left: var(--spacing-3);
                max-width: none;
                font-size: 0.875rem;
            }
            
            /* Kompaktere Power Charts auf Mobile */
            .power-chart canvas {
                max-height: 250px;
            }
            
            .status-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-2);
            }
            
            .status-item {
                padding: var(--spacing-2);
            }
            
            .status-value {
                font-size: 1rem;
            }
            
            .status-label {
                font-size: 0.75rem;
            }
        }
        
        /* Very small devices (360px and below) */
        @media (max-width: 360px) {
            .header h1 {
                font-size: 1.1rem;
            }
            
            .quick-scenes {
                grid-template-columns: 1fr 1fr;
            }
            
            .tab {
                min-width: 70px;
                font-size: 0.75rem;
                padding: var(--spacing-1) var(--spacing-2);
            }
            
            /* Power view tabs for very small screens */
            #power-tab .tabs .tab {
                font-size: 0.7rem;
                padding: var(--spacing-1);
                min-width: auto;
                flex: 1;
                background: var(--card-background);
                border: 1px solid rgba(255, 255, 255, 0.1);
                color: var(--text-primary);
                transition: all 0.3s ease;
                border-radius: var(--radius);
            }
            
            #power-tab .tabs .tab:hover {
                background: rgba(104, 141, 177, 0.1);
                border-color: var(--accent-blue);
            }
            
            #power-tab .tabs .tab.active {
                background: var(--accent-blue);
                border-color: var(--accent-blue);
                color: white;
                box-shadow: 0 2px 8px rgba(104, 141, 177, 0.3);
            }
            
            .floating-btn {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🏠Philips Hue Controller</h1>
            <div class="power-display">
                <span id="current-power">Lade Stromverbrauch...</span>
            </div>
        </div>

        <div id="messages"></div>

        <!-- Quick Scene Access -->
        <div class="card collapsible-card">
            <div class="card-title collapsible-header" onclick="toggleCard('quickaccess')">
                ⚡ Schnellzugriff
                <span class="collapse-icon" id="quickaccess-icon">▼</span>
            </div>
            <div class="collapsible-content" id="quickaccess-content">
                <div class="quick-scenes">
                    <div class="quick-scene" onclick="activateQuickScene('relax')">
                        <span class="icon">🛋️</span>
                        <div class="name">Entspannung</div>
                    </div>
                    <div class="quick-scene" onclick="activateQuickScene('work')">
                        <span class="icon">💼</span>
                        <div class="name">Arbeit</div>
                    </div>
                    <div class="quick-scene" onclick="activateQuickScene('party')">
                        <span class="icon">🎉</span>
                        <div class="name">Party</div>
                    </div>
                    <div class="quick-scene" onclick="activateQuickScene('romantic')">
                        <span class="icon">💕</span>
                        <div class="name">Romantik</div>
                    </div>
                    <div class="quick-scene" onclick="activateQuickScene('reading')">
                        <span class="icon">📖</span>
                        <div class="name">Lesen</div>
                    </div>
                    <div class="quick-scene" onclick="activateQuickScene('gaming')">
                        <span class="icon">🎮</span>
                        <div class="name">Gaming</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="global-controls collapsible-card">
            <div class="collapsible-header" onclick="toggleCard('globalcontrols')">
                <h3>🚨 Globale Steuerung</h3>
                <span class="collapse-icon" id="globalcontrols-icon">▼</span>
            </div>
            <div class="collapsible-content" id="globalcontrols-content">
                <div class="effect-controls">
                    <button class="btn" onclick="globalControl('all-on')">Alles An</button>
                    <button class="btn danger" onclick="globalControl('all-off')">Alles Aus</button>
                </div>
                
                <!-- Globaler Helligkeitsregler -->
                <div class="control-group" style="margin-top: 16px;">
                    <div class="slider-container">
                        <div class="slider-label">
                            <span>Helligkeit alle Lampen</span>
                            <span class="slider-value" id="global-brightness-value">100%</span>
                        </div>
                        <input type="range" class="slider" id="global-brightness-slider" min="1" max="254" value="254" 
                               oninput="document.getElementById('global-brightness-value').textContent = Math.round(this.value / 254 * 100) + '%'; globalBrightnessChange(this.value)">
                    </div>
                </div>

                <!-- Globale Farbauswahl -->
                <div class="control-group" style="margin-top: 20px;">
                    <h4>Beliebte Farben</h4>
                    <div class="color-quick-selection">
                        <button class="color-btn" style="background: #ff0000;" onclick="setGlobalColorHex('#ff0000')" title="Rot"></button>
                        <button class="color-btn" style="background: #00ff00;" onclick="setGlobalColorHex('#00ff00')" title="Grün"></button>
                        <button class="color-btn" style="background: #0066ff;" onclick="setGlobalColorHex('#0066ff')" title="Blau"></button>
                        <button class="color-btn" style="background: #ffff00;" onclick="setGlobalColorHex('#ffff00')" title="Gelb"></button>
                        <button class="color-btn" style="background: #ff00ff;" onclick="setGlobalColorHex('#ff00ff')" title="Magenta"></button>
                        <button class="color-btn" style="background: #00ffff;" onclick="setGlobalColorHex('#00ffff')" title="Cyan"></button>
                        <button class="color-btn" style="background: #ff8000;" onclick="setGlobalColorHex('#ff8000')" title="Orange"></button>
                        <button class="color-btn" style="background: #8000ff;" onclick="setGlobalColorHex('#8000ff')" title="Violett"></button>
                        <button class="color-btn" style="background: #fff2cc; color: black;" onclick="setGlobalColorHex('#fff2cc')" title="Warmweiß"></button>
                        <button class="color-btn" style="background: #ffffff; color: black;" onclick="setGlobalColorHex('#ffffff')" title="Kaltweiß"></button>
                        <button class="color-btn" style="background: #f5f5f5; color: black;" onclick="setGlobalColorHex('#f5f5f5')" title="Neutralweiß"></button>
                        <button class="color-btn" style="background: #fffacd; color: black;" onclick="setGlobalColorHex('#fffacd')" title="Tageslicht"></button>
                    </div>
                </div>
            </div>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="switchTab('lights')">Lichter</button>
            <button class="tab" onclick="switchTab('groups')">Gruppen</button>
            <button class="tab" onclick="switchTab('scenes')">Szenen</button>
            <button class="tab" onclick="switchTab('effects')">Effekte</button>
            <button class="tab" onclick="switchTab('timers')">Timer</button>
            <button class="tab" onclick="switchTab('sensors')">Sensoren</button>
            <button class="tab" onclick="switchTab('buttons')">Custom Buttons</button>
            <button class="tab" onclick="switchTab('debug')">Debug</button>
            <button class="tab" onclick="switchTab('power')">Stromverbrauch</button>
        </div>

        <div id="lights-tab" class="tab-content active">
            <div id="lights-container" class="controls-grid"></div>
        </div>

        <div id="groups-tab" class="tab-content">
            <div id="groups-container" class="controls-grid"></div>
        </div>

        <div id="scenes-tab" class="tab-content">
            <!-- Stimmungsszenen -->
            <div class="card">
                <div class="card-title">🎭 Stimmungsszenen</div>
                <div id="mood-scenes-container"></div>
            </div>
            
            <!-- Klassische Hue Szenen -->
            <div class="card">
                <div class="card-title">💡 Hue Szenen</div>
                <div id="scenes-container" class="scene-grid"></div>
            </div>
            
            <!-- Musik-Synchronisation -->
            <div class="card">
                <div class="card-title">🎵 Musik-Synchronisation</div>
                <div id="audio-sync-container">
                    <div class="control-group">
                        <h4>Audio-Gerät</h4>
                        <select id="audio-device-select" class="form-select">
                            <option value="">Audio-Geräte laden...</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <h4>Sync-Modus</h4>
                        <select id="sync-mode-select" class="form-select">
                            <option value="frequency">Frequenz-basiert</option>
                            <option value="beat">Beat-Synchronisation</option>
                            <option value="spectrum">Spektrum-Visualizer</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <h4>Empfindlichkeit</h4>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Reaktion</span>
                                <span class="slider-value" id="audio-sensitivity-value">50%</span>
                            </div>
                            <input type="range" class="slider" id="audio-sensitivity" min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateSliderValue('audio-sensitivity', Math.round(this.value * 100) + '%')">
                        </div>
                    </div>
                    
                    <div class="effect-controls">
                        <button class="btn" id="start-audio-sync" onclick="startAudioSync()">Musik-Sync starten</button>
                        <button class="btn danger" id="stop-audio-sync" onclick="stopAudioSync()" style="display: none;">Sync stoppen</button>
                    </div>
                    
                    <div id="audio-status" class="message" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div id="effects-tab" class="tab-content">
            <!-- Erweiterte Effekte -->
            <div class="card">
                <div class="card-title">🎨 Erweiterte Lichteffekte</div>
                <div class="advanced-effects">
                    <div class="effect-card" onclick="startAdvancedEffect('wave')">
                        <span class="icon">🌊</span>
                        <div class="name">Raumwelle</div>
                        <div class="description">Farben laufen durch alle Räume</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('pulse')">
                        <span class="icon">💓</span>
                        <div class="name">Pulsieren</div>
                        <div class="description">Rhythmisches Dimmen</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('rainbow')">
                        <span class="icon">🌈</span>
                        <div class="name">Regenbogen</div>
                        <div class="description">Sanfte Farbübergänge</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('fire')">
                        <span class="icon">🔥</span>
                        <div class="name">Feuer</div>
                        <div class="description">Warme, flackernde Farben</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('sunset')">
                        <span class="icon">🌅</span>
                        <div class="name">Sonnenuntergang</div>
                        <div class="description">Automatische Farbtemperatur</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('lightning')">
                        <span class="icon">⚡</span>
                        <div class="name">Blitz</div>
                        <div class="description">Zufällige Blitzeffekte</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('breathe')">
                        <span class="icon">💨</span>
                        <div class="name">Atmen</div>
                        <div class="description">Sanftes Pulsieren</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('twinkle')">
                        <span class="icon">✨</span>
                        <div class="name">Funkeln</div>
                        <div class="description">Zufällige Lichtfunken</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('disco')">
                        <span class="icon">🪩</span>
                        <div class="name">Disco</div>
                        <div class="description">Bunte Partystimmung</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('aurora')">
                        <span class="icon">🌌</span>
                        <div class="name">Nordlicht</div>
                        <div class="description">Sanfte Farbwellen</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('sparkle')">
                        <span class="icon">🌟</span>
                        <div class="name">Glitzer</div>
                        <div class="description">Kurze Lichtblitze</div>
                    </div>
                    <div class="effect-card" onclick="startAdvancedEffect('comet')">
                        <span class="icon">☄️</span>
                        <div class="name">Komet</div>
                        <div class="description">Wandernder Lichtschweif</div>
                    </div>
                </div>
            </div>

            <div class="controls-grid">
                <div class="card">
                    <div class="card-title">⚙️ Manuelle Effekte</div>
                    
                    <div class="control-group">
                        <h4>Ziel auswählen</h4>
                        <div class="input-group">
                            <select id="effect-target-type" class="form-select">
                                <option value="all">Alle Lichter</option>
                                <option value="light">Einzelnes Licht</option>
                                <option value="group">Gruppe</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <input type="text" id="effect-target-id" class="form-input" placeholder="ID (falls nicht 'Alle')">
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>Strobo Einstellungen</h4>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Dauer</span>
                                <span class="slider-value" id="strobe-duration-value">∞ Unbegrenzt</span>
                            </div>
                            <input type="range" class="slider" id="strobe-duration" min="0" max="300" value="0" oninput="updateNormalStrobeDurationValue(this.value)">
                            <div class="duration-info">
                                <small>0 = ∞ Unbegrenzt | 1-300 = Sekunden</small>
                            </div>
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Frequenz</span>
                                <span class="slider-value" id="strobe-frequency-value">2Hz</span>
                            </div>
                            <input type="range" class="slider" id="strobe-frequency" min="1" max="10" step="0.5" value="2" oninput="updateSliderValue('strobe-frequency', this.value + 'Hz')">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Helligkeit</span>
                                <span class="slider-value" id="strobe-brightness-value">254</span>
                            </div>
                            <input type="range" class="slider" id="strobe-brightness" min="50" max="254" value="254" oninput="updateSliderValue('strobe-brightness', this.value)">
                        </div>
                        <div class="color-selection-section">
                            <h5>🎨 Strobo-Farbe</h5>
                            <div class="color-quick-selection">
                                <button class="color-btn" style="background: #ff0000;" onclick="setNormalStroboColorHex('#ff0000')" title="Rot"></button>
                                <button class="color-btn" style="background: #00ff00;" onclick="setNormalStroboColorHex('#00ff00')" title="Grün"></button>
                                <button class="color-btn" style="background: #0066ff;" onclick="setNormalStroboColorHex('#0066ff')" title="Blau"></button>
                                <button class="color-btn" style="background: #ffff00;" onclick="setNormalStroboColorHex('#ffff00')" title="Gelb"></button>
                                <button class="color-btn" style="background: #ff00ff;" onclick="setNormalStroboColorHex('#ff00ff')" title="Magenta"></button>
                                <button class="color-btn" style="background: #00ffff;" onclick="setNormalStroboColorHex('#00ffff')" title="Cyan"></button>
                                <button class="color-btn" style="background: #ff8000;" onclick="setNormalStroboColorHex('#ff8000')" title="Orange"></button>
                                <button class="color-btn" style="background: #8000ff;" onclick="setNormalStroboColorHex('#8000ff')" title="Violett"></button>
                                <button class="color-btn" style="background: #fff2cc; color: black;" onclick="setNormalStroboColorHex('#fff2cc')" title="Warmweiß"></button>
                                <button class="color-btn" style="background: #ffffff; color: black;" onclick="setNormalStroboColorHex('#ffffff')" title="Kaltweiß"></button>
                                <button class="color-btn" style="background: #f5f5f5; color: black;" onclick="setNormalStroboColorHex('#f5f5f5')" title="Neutralweiß"></button>
                                <button class="color-btn" style="background: #fffacd; color: black;" onclick="setNormalStroboColorHex('#fffacd')" title="Tageslicht"></button>
                            </div>
                            
                            <!-- Hidden inputs for backward compatibility -->
                            <input type="hidden" id="strobe-hue" value="0">
                            <input type="hidden" id="strobe-sat" value="0">
                        </div>
                        <div class="input-group">
                            <label class="form-label">Modus:</label>
                            <select id="strobe-mode" class="form-select">
                                <option value="single">Einzelfarbe</option>
                                <option value="rainbow">Regenbogen</option>
                                <option value="multi">Mehrfarbig</option>
                            </select>
                        </div>
                        <button class="btn warning" onclick="startAdvancedStrobe()">Strobo Starten</button>
                    </div>


                </div>

                <div class="card">
                    <div class="card-title">🎯 Aktive Effekte</div>
                    <div id="effects-list" class="effect-list">
                        <div>Keine aktiven Effekte</div>
                    </div>
                    <button class="btn danger" onclick="stopAllEffects()" style="margin-top: 12px;">Alle Effekte Stoppen</button>
                </div>
            </div>
        </div>

        <div id="timers-tab" class="tab-content">
            <div class="controls-grid">
                <div class="card">
                    <div class="card-title">Timer erstellen</div>
                    <div class="input-group">
                        <label class="form-label">Ziel wählen:</label>
                        <select id="timer-target-type" class="form-select">
                            <option value="light">Einzelnes Licht</option>
                            <option value="group">Gruppe</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label class="form-label">ID:</label>
                        <input type="text" id="timer-target-id" class="form-input" placeholder="z.B. 1">
                    </div>
                    <div class="input-group">
                        <label class="form-label">Verzögerung (Sekunden):</label>
                        <input type="number" id="timer-delay" class="form-input" value="60" min="1" max="86400">
                    </div>
                    <div class="input-group">
                        <label class="form-label">Aktion:</label>
                        <select id="timer-action" class="form-select">
                            <option value="off">Ausschalten</option>
                            <option value="on">Einschalten</option>
                        </select>
                    </div>
                    <button class="btn" onclick="createTimer()">Timer Erstellen</button>
                </div>

                <div class="card">
                    <div class="card-title">Aktive Timer</div>
                    <div id="timers-list" class="timer-list">
                        <div>Keine aktiven Timer</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="sensors-tab" class="tab-content">
            <div id="sensors-container" class="controls-grid"></div>
        </div>

        <div id="debug-tab" class="tab-content">
            <div class="card">
                <div class="card-title">🐛 Live Debug Monitor</div>
                
                <div class="control-group">
                    <h4>Hue Bridge Kommunikation</h4>
                    <div class="debug-controls">
                        <button class="btn" onclick="clearDebugLog()">Log Löschen</button>
                        <button class="btn" onclick="toggleDebugAutoScroll()">Auto-Scroll: <span id="autoscroll-status">AN</span></button>
                        <label class="form-label">
                            Max Entries: 
                            <select id="max-log-entries" class="form-select" onchange="updateMaxLogEntries()">
                                <option value="50">50</option>
                                <option value="100" selected>100</option>
                                <option value="200">200</option>
                                <option value="500">500</option>
                            </select>
                        </label>
                    </div>
                    
                    <div class="debug-log-container">
                        <div id="debug-log" class="debug-log">
                            <div class="debug-entry info">
                                <span class="debug-time">--:--:--</span>
                                <span class="debug-type">INFO</span>
                                <span class="debug-message">Debug Monitor gestartet</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h4>Bridge Status</h4>
                    <div class="status-grid">
                        <div class="status-item">
                            <div class="status-value" id="debug-bridge-status">🔍</div>
                            <div class="status-label">Bridge Verbindung</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="debug-last-request">--</div>
                            <div class="status-label">Letzte Anfrage</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="debug-request-count">0</div>
                            <div class="status-label">Anfragen (heute)</div>
                        </div>
                        <div class="status-item">
                            <div class="status-value" id="debug-error-count">0</div>
                            <div class="status-label">Fehler</div>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h4>Test-Befehle</h4>
                    <div class="debug-test-grid">
                        <button class="btn" onclick="testHueConnection()">Bridge Testen</button>
                        <button class="btn" onclick="testLightCommand()">Licht Testen</button>
                        <button class="btn" onclick="testGroupCommand()">Gruppe Testen</button>
                        <button class="btn warning" onclick="sendTestStrobe()">Test-Strobo</button>
                        <button class="btn" onclick="checkSystemHealth()">System-Gesundheit</button>
                    </div>
                </div>
            </div>
        </div>

        <div id="power-tab" class="tab-content">
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-value" id="current-watts">0W</div>
                    <div class="status-label">Aktueller Verbrauch</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="active-lights-count">0</div>
                    <div class="status-label">Aktive Lichter</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="monthly-estimate">0 kWh</div>
                    <div class="status-label">Monatlicher Verbrauch</div>
                </div>
                <div class="status-item">
                    <div class="status-value" id="monthly-cost">0€</div>
                    <div class="status-label">Monatliche Kosten</div>
                </div>
            </div>
            
            <!-- Zeitraum-Auswahl -->
            <div class="card" style="margin-top: var(--spacing-6);">
                <div class="tabs" style="margin-bottom: 0;">
                    <button class="tab active" data-view="today" onclick="switchPowerView('today')">Heute</button>
                    <button class="tab" data-view="week" onclick="switchPowerView('week')">Woche</button>
                    <button class="tab" data-view="month" onclick="switchPowerView('month')">Monat</button>
                    <button class="tab" data-view="year" onclick="switchPowerView('year')">Jahr</button>
                    <button class="tab" data-view="weekday" onclick="switchPowerView('weekday')">Wochentage</button>
                    <button class="tab" data-view="seasonal" onclick="switchPowerView('seasonal')">Sommer/Winter</button>
                </div>
            </div>
            
            <!-- Hauptchart -->
            <div class="power-chart">
                <div class="card-title" id="chart-title">Verbrauchsverlauf - Heute</div>
                <canvas id="powerChart"></canvas>
            </div>
            
            <!-- Wochentags-Analyse -->
            <div class="card power-chart" id="weekday-analysis" style="display: none; margin-top: var(--spacing-6);">
                <div class="card-title">Durchschnittlicher Verbrauch pro Wochentag</div>
                <canvas id="weekdayChart"></canvas>
                <div class="card-title" style="margin-top: var(--spacing-6);">Stündlicher Verbrauch - Heatmap</div>
                <canvas id="weekdayHeatmap"></canvas>
            </div>
            
            <!-- Monatsvergleich -->
            <div class="card power-chart" id="monthly-comparison" style="display: none; margin-top: var(--spacing-6);">
                <div class="card-title">Monatsvergleich (letzte 12 Monate)</div>
                <canvas id="monthlyChart"></canvas>
            </div>
            
            <!-- Sommer/Winter Vergleich -->
            <div class="card power-chart" id="seasonal-comparison" style="display: none; margin-top: var(--spacing-6);">
                <div class="card-title">Sommer vs. Winter Verbrauch</div>
                <div class="controls-grid" style="grid-template-columns: 1fr 1fr; margin-bottom: var(--spacing-4);">
                    <div>
                        <canvas id="seasonalPieChart"></canvas>
                    </div>
                    <div>
                        <canvas id="seasonalHourlyChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Detaillierte Statistiken -->
            <div class="card" style="margin-top: var(--spacing-6);">
                <div class="card-title">Detaillierte Statistiken</div>
                <div id="detailed-stats" class="status-grid">
                    <!-- Wird dynamisch gefüllt -->
                </div>
            </div>
            
            <!-- Individuelle Lampen-Analyse -->
            <div class="card" style="margin-top: var(--spacing-6);">
                <div class="card-title">Individuelle Lampen-Analyse</div>
                <div class="controls-grid" style="margin-bottom: var(--spacing-4);">
                    <div>
                        <label class="form-label">Lampen auswählen:</label>
                        <div id="lamp-selection" class="lamp-selection-grid" style="max-height: 200px; overflow-y: auto; padding: var(--spacing-2); background: rgba(255, 255, 255, 0.05); border-radius: var(--radius-lg); border: 1px solid rgba(255, 255, 255, 0.1);">
                            <!-- Wird dynamisch mit Checkboxen gefüllt -->
                        </div>
                    </div>
                    <div>
                        <label class="form-label">Zeitraum:</label>
                        <select id="individual-lamp-timeframe" class="form-select" onchange="updateIndividualLampChart()">
                            <option value="today">Heute</option>
                            <option value="week">Diese Woche</option>
                            <option value="month">Dieser Monat</option>
                        </select>
                        <button class="btn" style="margin-top: var(--spacing-2); width: 100%;" onclick="updateIndividualLampChart()">Chart aktualisieren</button>
                    </div>
                </div>
                <div class="power-chart">
                    <canvas id="individualLampChart"></canvas>
                </div>
            </div>
            
            <!-- Top Verbraucher -->
            <div class="card" style="margin-top: var(--spacing-6);">
                <div class="card-title">Top Verbraucher <span id="top-consumer-timeframe">heute</span></div>
                <div id="top-consumers"></div>
            </div>
            
            <!-- Licht-Details -->
            <div class="card" style="margin-top: var(--spacing-6);">
                <div class="card-title">Licht-Details</div>
                <div style="padding: var(--spacing-3); background: rgba(225, 97, 98, 0.1); border-radius: var(--radius); margin-bottom: var(--spacing-4); font-size: 0.875rem;">
                    <strong>Hinweis:</strong> Nicht erreichbare Lichter (⚠️) verbrauchen weiterhin Strom, wenn sie eingeschaltet sind.
                </div>
                <div id="light-power-details"></div>
            </div>
        </div>

        <div id="guide-tab" class="tab-content">
            <div class="guide-container">
                <div class="card">
                    <div class="card-title">📚Philips Hue Controller - Vollständige Anleitung</div>
                    <div class="guide-nav">
                        <button class="guide-nav-btn active" onclick="showGuideSection('overview')">🏠 Übersicht</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('quickstart')">⚡ Schnellstart</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('lights')">💡 Lichtsteuerung</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('colors')">🎨 Farben & Szenen</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('effects')">🔥 Effekte</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('monitoring')">📊 Monitoring</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('advanced')">🛠️ Erweitert</button>
                        <button class="guide-nav-btn" onclick="showGuideSection('troubleshooting')">❓ Hilfe</button>
                    </div>
                </div>

                <!-- Übersicht Section -->
                <div id="guide-overview" class="guide-section active">
                    <div class="card">
                        <div class="card-title">🏠 Was kannPhilips Hue Controller?</div>
                        <div class="guide-content">
                            <h3>✨ Hauptfunktionen:</h3>
                            <ul>
                                <li><strong>💡 Intelligente Lichtsteuerung</strong> - Ein/Aus, Helligkeit, Farben für alle Hue-Geräte</li>
                                <li><strong>🎨 Kreative Szenen</strong> - Vordefinierte Stimmungen und eigene Kreationen</li>
                                <li><strong>🔥 Spektakuläre Effekte</strong> - Strobo, Colorloop, Ultra-Blitz und mehr</li>
                                <li><strong>📊 Power Monitoring</strong> - Echter Stromverbrauch und Kostenkontrolle</li>
                                <li><strong>🏠 Gruppen-Management</strong> - Raumweise Steuerung aller Lichter</li>
                                <li><strong>⏰ Timer & Automation</strong> - Zeitgesteuerte Aktionen</li>
                            </ul>
                            
                            <h3>🚀 Performance Features:</h3>
                            <ul>
                                <li><strong>⚡ Ultra-schnelle Reaktion</strong> - Optimierte API-Calls mit Smart Caching</li>
                                <li><strong>🎯 Debouncing-System</strong> - Keine Verzögerungen bei Slider-Bewegungen</li>
                                <li><strong>📱 Mobile-Optimiert</strong> - Touch-freundliche Bedienung</li>
                                <li><strong>🌐 Offline-Fähig</strong> - Progressive Web App Technology</li>
                            </ul>

                            <div class="warning-box">
                                <strong>⚠️ Sicherheitshinweis:</strong><br>
                                Die Strobo-Effekte können bei photosensitiven Personen epileptische Anfälle auslösen. 
                                Verwenden Sie hohe Frequenzen (>15Hz) nur mit äußerster Vorsicht!
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Schnellstart Section -->
                <div id="guide-quickstart" class="guide-section">
                    <div class="card">
                        <div class="card-title">⚡ In 3 Minuten einsatzbereit</div>
                        <div class="guide-content">
                            <h3>🔧 Setup (einmalig):</h3>
                            <ol>
                                <li><strong>Hue Bridge finden:</strong> App automatisch erkennt Bridge im Netzwerk</li>
                                <li><strong>Bridge-Button drücken:</strong> Physischen Button an der Bridge drücken</li>
                                <li><strong>Verbindung bestätigen:</strong> App erhält automatisch Zugriff</li>
                            </ol>

                            <h3>🚀 Sofort loslegen:</h3>
                            <div class="quick-actions">
                                <div class="quick-action">
                                    <div class="quick-icon">💡</div>
                                    <div class="quick-text">
                                        <strong>Home Tab</strong><br>
                                        Alle Lichter sehen und einzeln steuern
                                    </div>
                                </div>
                                <div class="quick-action">
                                    <div class="quick-icon">🎨</div>
                                    <div class="quick-text">
                                        <strong>Szenen Tab</strong><br>
                                        Voreingestellte Stimmungen aktivieren
                                    </div>
                                </div>
                                <div class="quick-action">
                                    <div class="quick-icon">✨</div>
                                    <div class="quick-text">
                                        <strong>Effekte Tab</strong><br>
                                        Spektakuläre Lichtshows starten
                                    </div>
                                </div>
                                <div class="quick-action">
                                    <div class="quick-icon">🏠</div>
                                    <div class="quick-text">
                                        <strong>Räume Tab</strong><br>
                                        Ganze Zimmer auf einmal steuern
                                    </div>
                                </div>
                            </div>

                            <h3>⚡ Sofort-Aktionen:</h3>
                            <div class="shortcut-grid">
                                <div class="shortcut-item">🌟 Alles An</div>
                                <div class="shortcut-item">💡 Alles Aus</div>
                                <div class="shortcut-item">🚨 Notfall-Stopp</div>
                                <div class="shortcut-item">🎨 Schnell-Szenen</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Weitere Sections werden hier eingefügt... -->
                <div id="guide-lights" class="guide-section">
                    <div class="card">
                        <div class="card-title">💡 Lichtsteuerung Meistern</div>
                        <div class="guide-content">
                            <h3>🔧 Grundsteuerung:</h3>
                            <ul>
                                <li><strong>Ein/Aus:</strong> Großer Button - sofortige Reaktion</li>
                                <li><strong>Helligkeit:</strong> Slider bewegen - optimistische Updates</li>
                                <li><strong>Farbe:</strong> Color Picker oder Farbpalette verwenden</li>
                            </ul>

                            <h3>🎨 Farbauswahl:</h3>
                            <div class="color-demo">
                                <div class="color-method">
                                    <strong>1. Color Picker</strong><br>
                                    Präzise Farbwahl mit Hex-Werten
                                </div>
                                <div class="color-method">
                                    <strong>2. Farbpalette</strong><br>
                                    6 beliebte Farben per Klick
                                </div>
                                <div class="color-method">
                                    <strong>3. Voreinstellungen</strong><br>
                                    Strobo: Weiß, Rot, Blau, Grün, Lila, Orange
                                </div>
                            </div>

                            <h3>⚡ Performance-Tipps:</h3>
                            <ul>
                                <li><strong>Slider:</strong> Bewegen Sie ruhig schnell - Debouncing verhindert Spam</li>
                                <li><strong>Gruppen:</strong> Verwenden Sie Räume für bessere Performance</li>
                                <li><strong>Transitions:</strong> Sanfte Übergänge für professionelle Effekte</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Effects Guide -->
                <div id="guide-effects" class="guide-section">
                    <div class="card">
                        <div class="card-title">🔥 Effekte & Strobo-Modi</div>
                        <div class="guide-content">
                            <h3>💫 Standard-Effekte:</h3>
                            <div class="effects-grid">
                                <div class="effect-card">
                                    <div class="effect-name">🌈 Colorloop</div>
                                    <div class="effect-desc">Sanfter Farbverlauf durch das gesamte Spektrum</div>
                                </div>
                                <div class="effect-card">
                                    <div class="effect-name">⚡ Normaler Strobo</div>
                                    <div class="effect-desc">1-10Hz, konfigurierbare Farben, unbegrenzte Dauer</div>
                                </div>
                                <div class="effect-card">
                                    <div class="effect-name">🔥 Ultra-Strobo</div>
                                    <div class="effect-desc">10-25Hz, extrem aggressive Blitze</div>
                                </div>
                            </div>

                            <h3>🚨 Ultra-Strobo Modi:</h3>
                            <ul>
                                <li><strong>⚡ ULTRA (15Hz):</strong> Kontinuierliche Blitze mit extremer Geschwindigkeit</li>
                                <li><strong>💥 BURST:</strong> 4-5 schnelle Blitze, dann Pause</li>
                                <li><strong>🚔 POLIZEI:</strong> Rot-Blau Wechsel mit Sirenen-Feeling</li>
                                <li><strong>🪩 DISCO:</strong> Zufällige Farben und Frequenzen</li>
                            </ul>

                            <div class="warning-box">
                                <strong>🚨 EPILEPSIE-WARNUNG!</strong><br>
                                • Frequenzen >15Hz sind besonders gefährlich<br>
                                • Sofortiger Notfall-Stopp verfügbar<br>
                                • Unbegrenzte Dauer: 0 = ∞, sonst Sekunden<br>
                                • Bei Problemen: Notfall-Stopp oder Browser schließen
                            </div>

                            <h3>🎯 Strobo-Konfiguration:</h3>
                            <ul>
                                <li><strong>Frequenz:</strong> 1-25Hz (Vorsicht bei >15Hz!)</li>
                                <li><strong>Dauer:</strong> 0 = Unbegrenzt, 1-300 Sekunden</li>
                                <li><strong>Farben:</strong> 6 Presets oder eigene Auswahl</li>
                                <li><strong>Ziele:</strong> Einzelne Lichter, Gruppen oder alle</li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- Troubleshooting -->
                <div id="guide-troubleshooting" class="guide-section">
                    <div class="card">
                        <div class="card-title">❓ Probleme lösen</div>
                        <div class="guide-content">
                            <h3>🐛 Häufige Probleme:</h3>
                            
                            <div class="problem-solution">
                                <div class="problem">❌ Lichter reagieren nicht</div>
                                <div class="solution">
                                    • Bridge-Verbindung prüfen (Debug-Tab)<br>
                                    • WLAN-Verbindung der Bridge überprüfen<br>
                                    • Bridge neustarten (Stromkabel ziehen)
                                </div>
                            </div>

                            <div class="problem-solution">
                                <div class="problem">🐌 App reagiert langsam</div>
                                <div class="solution">
                                    • Browser-Cache leeren<br>
                                    • Andere Tabs schließen<br>
                                    • WLAN-Qualität prüfen<br>
                                    • Performance-Features sind aktiv (Debouncing)
                                </div>
                            </div>

                            <div class="problem-solution">
                                <div class="problem">⚡ Strobo stoppt nicht</div>
                                <div class="solution">
                                    • <strong>NOTFALL-STOPP</strong> Button verwenden<br>
                                    • Browser-Tab schließen<br>
                                    • Bridge-Stromkabel ziehen<br>
                                    • Hue-App als Backup verwenden
                                </div>
                            </div>

                            <h3>🔧 Debug-Tools verwenden:</h3>
                            <ul>
                                <li><strong>Debug-Tab:</strong> Live API-Requests verfolgen</li>
                                <li><strong>Test-Funktionen:</strong> Bridge-Verbindung testen</li>
                                <li><strong>Performance-Metriken:</strong> Antwortzeiten prüfen</li>
                                <li><strong>Error-Logs:</strong> Fehlerdetails einsehen</li>
                            </ul>

                            <h3>📞 Support-Informationen:</h3>
                            <div class="support-info">
                                <strong>System-Informationen:</strong><br>
                                • App:Philips Hue Controller<br>
                                • Version: 2.0 Performance Edition<br>
                                • Features: Smart Caching, Debouncing, Ultra-Strobo<br>
                                • Browser: Chrome/Firefox/Safari empfohlen
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Weitere Sections placeholder -->
                <div id="guide-colors" class="guide-section">
                    <div class="card">
                        <div class="card-title">🎨 Farben & Szenen</div>
                        <div class="guide-content">
                            <p>Detaillierte Anleitung zu Farben und Szenen kommt hier...</p>
                        </div>
                    </div>
                </div>

                <div id="guide-monitoring" class="guide-section">
                    <div class="card">
                        <div class="card-title">📊 Power Monitoring</div>
                        <div class="guide-content">
                            <p>Stromverbrauch-Monitoring Anleitung kommt hier...</p>
                        </div>
                    </div>
                </div>

                <div id="guide-advanced" class="guide-section">
                    <div class="card">
                        <div class="card-title">🛠️ Erweiterte Features</div>
                        <div class="guide-content">
                            <p>Profi-Features und API-Zugriff kommt hier...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="buttons-tab" class="tab-content">
            <div class="card">
                <div class="card-title">🔘 Custom Button Konfiguration</div>
                <div class="card-content">
                    <p>Konfiguriere physische Buttons (GPIO) zur direkten Steuerung von Hue-Gruppen.</p>
                    
                    <!-- GPIO Status -->
                    <div id="gpio-status" class="status-indicator">
                        <span class="status-dot"></span>
                        <span id="gpio-status-text">GPIO Status wird geladen...</span>
                    </div>
                    
                    <!-- Button hinzufügen -->
                    <div class="button-config-form">
                        <h3>🆕 Neuen Button hinzufügen</h3>
                        <div class="form-grid">
                            <div class="form-field">
                                <label for="gpio-pin">GPIO Pin:</label>
                                <input type="number" id="gpio-pin" min="2" max="27" placeholder="z.B. 26">
                            </div>
                            <div class="form-field">
                                <label for="button-group">Gruppe:</label>
                                <select id="button-group">
                                    <option value="">-- Gruppe wählen --</option>
                                </select>
                            </div>
                            <div class="form-field">
                                <label for="button-action">Aktion:</label>
                                <select id="button-action">
                                    <option value="toggle">Toggle (Ein/Aus)</option>
                                    <option value="on">Immer Ein</option>
                                    <option value="off">Immer Aus</option>
                                </select>
                            </div>
                            <div class="form-field">
                                <label for="button-name">Name (optional):</label>
                                <input type="text" id="button-name" placeholder="z.B. Wohnzimmer Button">
                            </div>
                        </div>
                        <button class="action-btn" onclick="addButtonConfiguration()">
                            ➕ Button hinzufügen
                        </button>
                    </div>
                </div>
            </div>

            <!-- Konfigurierte Buttons -->
            <div class="card">
                <div class="card-title">⚙️ Aktuelle Konfiguration</div>
                <div id="button-configurations" class="button-configs-container">
                    <div class="loading-spinner">Lade Konfigurationen...</div>
                </div>
            </div>

            <!-- Button-Logs -->
            <div class="card">
                <div class="card-title">📋 Button Activity Log</div>
                <div class="button-logs-header">
                    <button class="small-btn" onclick="loadButtonLogs()">🔄 Aktualisieren</button>
                    <button class="small-btn" onclick="clearButtonLogs()" style="background: var(--accent-red);">🗑️ Logs löschen</button>
                </div>
                <div id="button-logs" class="logs-container">
                    <div class="loading-spinner">Lade Logs...</div>
                </div>
            </div>
        </div>

        <!-- Schwebende Steuerungselemente -->
        <div class="floating-controls">
            <button class="floating-btn" onclick="globalControl('all-off')" title="Alles Aus" style="background: linear-gradient(135deg, #f44336 0%, #da190b 100%);">💡</button>
            <button class="floating-btn" onclick="globalControl('all-on')" title="Alles An" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">🌟</button>
        </div>
    </div>

    <!-- Bottom Navigation (Mobile) -->
    <nav class="bottom-nav">
        <div class="nav-item active" onclick="switchTab('lights')" data-tab="lights">
            <div class="nav-icon">💡</div>
            <div class="nav-label">Home</div>
        </div>
        <div class="nav-item" onclick="switchTab('scenes')" data-tab="scenes">
            <div class="nav-icon">🎨</div>
            <div class="nav-label">Szenen</div>
        </div>
        <div class="nav-item" onclick="switchTab('effects')" data-tab="effects">
            <div class="nav-icon">✨</div>
            <div class="nav-label">Effekte</div>
        </div>
        <div class="nav-item" onclick="switchTab('groups')" data-tab="groups">
            <div class="nav-icon">🏠</div>
            <div class="nav-label">Räume</div>
        </div>
        <div class="nav-item" onclick="switchTab('buttons')" data-tab="buttons">
            <div class="nav-icon">🔘</div>
            <div class="nav-label">Buttons</div>
        </div>
        <div class="nav-item" onclick="switchTab('debug')" data-tab="debug">
            <div class="nav-icon">🐛</div>
            <div class="nav-label">Debug</div>
        </div>
        <div class="nav-item" onclick="switchTab('power')" data-tab="power">
            <div class="nav-icon">⚡</div>
            <div class="nav-label">Verbrauch</div>
        </div>
        <div class="nav-item" onclick="switchTab('guide')" data-tab="guide">
            <div class="nav-icon">📚</div>
            <div class="nav-label">Anleitung</div>
        </div>
    </nav>

    <script>
        // Smart Debouncing System für Performance
        class SmartDebouncer {
            constructor() {
                this.timers = new Map();
                this.pendingRequests = new Map();
            }

            debounce(key, func, delay = 300) {
                if (this.timers.has(key)) {
                    clearTimeout(this.timers.get(key));
                }
                
                this.timers.set(key, setTimeout(() => {
                    func();
                    this.timers.delete(key);
                }, delay));
            }

            immediate(key, func) {
                // Sofortiger UI-Update für Responsiveness
                func();
            }
        }

        // Globaler Debouncer
        const debouncer = new SmartDebouncer();

        class HueControllerPro {
            constructor() {
                this.baseUrl = window.location.origin;
                this.activeTab = 'lights';
                this.updateInterval = null;
                this.effectsUpdateInterval = null;
                this.powerUpdateInterval = null;
                this.powerChart = null;
                this.powerChartUpdateTimeout = null; // Track chart update timeout
                this.requestCache = new Map();
                this.lastRequests = new Map();
                this.activeStrobes = {}; // Verfolge aktive Strobe-Effekte
                this.lastSelectedColors = {}; // Verfolge letzte Farbauswahl pro Licht
                this.selectedStrobeSpeeds = {}; // Verfolge gewählte Strobo-Geschwindigkeiten
                this.init();
            }

            // Get CSS variable colors as actual values
            getChartColors() {
                const style = getComputedStyle(document.documentElement);
                return {
                    blue: style.getPropertyValue('--accent-blue').trim() || '#688db1',
                    red: style.getPropertyValue('--accent-red').trim() || '#e16162',
                    green: style.getPropertyValue('--accent-green').trim() || '#9cb68f',
                    // Create rgba versions for backgrounds
                    blueAlpha: (alpha = 0.1) => {
                        const blue = style.getPropertyValue('--accent-blue').trim() || '#688db1';
                        const rgb = blue.startsWith('#') ? this.hexToRgb(blue) : blue;
                        return rgb.includes('rgb') ? rgb.replace('rgb', 'rgba').replace(')', `, ${alpha})`) : `rgba(104, 141, 177, ${alpha})`;
                    },
                    redAlpha: (alpha = 0.1) => {
                        const red = style.getPropertyValue('--accent-red').trim() || '#e16162';
                        const rgb = red.startsWith('#') ? this.hexToRgb(red) : red;
                        return rgb.includes('rgb') ? rgb.replace('rgb', 'rgba').replace(')', `, ${alpha})`) : `rgba(225, 97, 98, ${alpha})`;
                    },
                    greenAlpha: (alpha = 0.1) => {
                        const green = style.getPropertyValue('--accent-green').trim() || '#9cb68f';
                        const rgb = green.startsWith('#') ? this.hexToRgb(green) : green;
                        return rgb.includes('rgb') ? rgb.replace('rgb', 'rgba').replace(')', `, ${alpha})`) : `rgba(156, 182, 143, ${alpha})`;
                    }
                };
            }

            // Helper to convert hex to rgb
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? 
                    `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` :
                    hex;
            }

            async init() {
                // Gespeicherten Tab-Status wiederherstellen
                const savedTab = localStorage.getItem('hue-active-tab');
                if (savedTab) {
                    this.activeTab = savedTab;
                    // Tab-UI aktualisieren
                    setTimeout(() => this.switchTab(savedTab), 100);
                }
                
                try {
                    await this.loadLights();
                    await this.loadGroups();
                    await this.loadScenes();
                    await this.loadMoodScenes();
                    await this.loadAudioDevices();
                    await this.loadSensors();
                    await this.updateActiveEffects();
                    await this.updateActiveTimers();
                    await this.updatePowerStats();
                    
                    
                    // Live-Updates starten
                    this.startLiveUpdates();
                } catch (error) {
                    this.showMessage('Fehler beim Laden: ' + error.message, 'error');
                }
            }

            switchTab(tabName) {
                // Desktop tab buttons
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                if (event && event.target.classList.contains('tab')) {
                    event.target.classList.add('active');
                }
                
                // Bottom navigation items
                document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
                const activeNavItem = document.querySelector(`[data-tab="${tabName}"]`);
                if (activeNavItem) {
                    activeNavItem.classList.add('active');
                }
                
                // Tab content
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(tabName + '-tab').classList.add('active');
                
                this.activeTab = tabName;
                
                // Tab-Status in localStorage speichern
                localStorage.setItem('hue-active-tab', tabName);
                
                // Update charts when switching to power tab
                if (tabName === 'power') {
                    // Clear any pending chart updates
                    if (this.powerChartUpdateTimeout) {
                        clearTimeout(this.powerChartUpdateTimeout);
                    }
                    
                    // Only load the current power view once
                    this.powerChartUpdateTimeout = setTimeout(() => {
                        // Only call switchPowerView, which will handle all chart rendering
                        this.switchPowerView(this.currentPowerView || 'today');
                    }, 100);
                }
            }

            async loadLights() {
                const response = await fetch(`${this.baseUrl}/api/lights`);
                const lights = await response.json();
                this.renderLights(lights);
            }

            async loadGroups() {
                const response = await fetch(`${this.baseUrl}/api/groups`);
                const groups = await response.json();
                this.renderGroups(groups);
            }

            async loadScenes() {
                const response = await fetch(`${this.baseUrl}/api/scenes`);
                const scenes = await response.json();
                this.renderScenes(scenes);
            }

            async loadSensors() {
                const response = await fetch(`${this.baseUrl}/api/sensors`);
                const sensors = await response.json();
                this.renderSensors(sensors);
            }

            async loadMoodScenes() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/mood-scenes`);
                    const data = await response.json();
                    if (data.success) {
                        this.renderMoodScenes(data.scenes);
                    }
                } catch (error) {
                    console.error('Fehler beim Laden der Stimmungsszenen:', error);
                }
            }

            async loadAudioDevices() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/audio/devices`);
                    const data = await response.json();
                    if (data.success) {
                        this.renderAudioDevices(data.devices);
                    } else {
                        document.getElementById('audio-device-select').innerHTML = 
                            '<option value="">Audio nicht verfügbar</option>';
                    }
                } catch (error) {
                    console.error('Fehler beim Laden der Audio-Geräte:', error);
                }
            }

            renderLights(lights) {
                const container = document.getElementById('lights-container');
                container.innerHTML = '';

                Object.entries(lights).forEach(([id, light]) => {
                    const card = this.createLightCard(id, light, 'light');
                    this.addCardAnimation(card);
                    container.appendChild(card);
                });
            }

            renderGroups(groups) {
                const container = document.getElementById('groups-container');
                container.innerHTML = '';

                Object.entries(groups).forEach(([id, group]) => {
                    if (group.name !== 'Lightset 0') {
                        const card = this.createLightCard(id, group, 'group');
                        this.addCardAnimation(card);
                        container.appendChild(card);
                    }
                });
            }

            renderScenes(scenes) {
                const container = document.getElementById('scenes-container');
                container.innerHTML = '';

                Object.entries(scenes).forEach(([id, scene]) => {
                    const btn = document.createElement('div');
                    btn.className = 'scene-btn';
                    btn.innerHTML = scene.name;
                    btn.onclick = () => this.activateScene(id, scene);
                    container.appendChild(btn);
                });
            }

            renderSensors(sensors) {
                const container = document.getElementById('sensors-container');
                container.innerHTML = '';

                Object.entries(sensors).forEach(([id, sensor]) => {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.innerHTML = `
                        <div class="card-title">${sensor.name}</div>
                        <div>Typ: ${sensor.type}</div>
                        <div>Status: ${sensor.config?.on ? 'Aktiv' : 'Inaktiv'}</div>
                        <div>Batterie: ${sensor.config?.battery || 'N/A'}%</div>
                    `;
                    container.appendChild(card);
                });
            }

            renderMoodScenes(scenes) {
                const container = document.getElementById('mood-scenes-container');
                container.innerHTML = '';

                const categories = {
                    natural: 'Natürliche Szenen',
                    emotional: 'Emotionale Szenen', 
                    activity: 'Aktivitäts-Szenen'
                };

                Object.entries(categories).forEach(([categoryKey, categoryName]) => {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'mood-category';
                    
                    const title = document.createElement('div');
                    title.className = 'mood-category-title';
                    title.innerHTML = `<span>${categoryName}</span>`;
                    categoryDiv.appendChild(title);

                    const grid = document.createElement('div');
                    grid.className = 'mood-scenes-grid';

                    scenes[categoryKey]?.forEach(scene => {
                        const card = document.createElement('div');
                        card.className = 'mood-scene-card';
                        card.onclick = () => this.activateMoodScene(scene.id);
                        
                        card.innerHTML = `
                            <div class="mood-scene-icon">${scene.icon}</div>
                            <div class="mood-scene-name">${scene.name}</div>
                            <div class="mood-scene-category">${scene.category}</div>
                        `;
                        
                        grid.appendChild(card);
                    });

                    categoryDiv.appendChild(grid);
                    container.appendChild(categoryDiv);
                });
            }

            renderAudioDevices(devices) {
                const select = document.getElementById('audio-device-select');
                select.innerHTML = '<option value="">Gerät auswählen</option>';
                
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.index;
                    option.textContent = `${device.name} (${device.channels} Kanäle)`;
                    select.appendChild(option);
                });
            }

            createLightCard(id, item, type) {
                const card = document.createElement('div');
                
                const state = type === 'light' ? item.state : item.action;
                const isReachable = type === 'light' ? (state.reachable !== false) : true; // Groups are always reachable
                // Use on_display for UI (shows unreachable lights as off) but keep original state.on for power calculations
                const isOn = type === 'light' && state.on_display !== undefined ? state.on_display : state.on;
                const brightness = Math.round((state.bri || 0) / 254 * 100);
                const supportsColor = type === 'light' ? (item.capabilities?.control?.colorgamut !== undefined) : true;
                
                // Set card classes based on reachability and light state
                let cardClasses = 'card';
                if (!isReachable) {
                    cardClasses += ' unreachable';
                } else if (isOn) {
                    cardClasses += ' light-on';
                }
                card.className = cardClasses;

                // Apply actual light color as glow effect for active lights
                if (isReachable && isOn && supportsColor) {
                    const hue = state.hue || 0;
                    const sat = state.sat || 0;
                    const currentColor = this.hueToHex(hue, sat);
                    const [r, g, b] = [
                        parseInt(currentColor.slice(1, 3), 16),
                        parseInt(currentColor.slice(3, 5), 16),
                        parseInt(currentColor.slice(5, 7), 16)
                    ];
                    
                    card.style.boxShadow = `0 0 20px rgba(${r}, ${g}, ${b}, 0.3), 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.15)`;
                    card.style.borderColor = `rgba(${r}, ${g}, ${b}, 0.4)`;
                }

                card.innerHTML = `
                    <div class="card-title">
                        ${item.name} 
                        ${isReachable ? (isOn ? '💡' : '🔆') : '❌'}
                    </div>
                    
                    <button class="btn ${this.getButtonClass(isOn, isReachable)}" 
                            onclick="hue.toggle('${id}', ${!isOn}, '${type}')"
                            ${!isReachable ? 'disabled' : ''}>
                        ${this.getButtonText(isOn, isReachable)}
                    </button>
                    
                    <div class="control-group" style="margin-top: 16px;">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Helligkeit</span>
                                <span class="slider-value">${brightness}%</span>
                            </div>
                            <input type="range" class="slider" min="1" max="254" value="${state.bri || 254}" 
                                   oninput="this.nextElementSibling.textContent = Math.round(this.value / 254 * 100) + '%'; hue.setBrightness('${id}', this.value, '${type}')"
                                   ${!isReachable ? 'disabled' : ''}>
                            <div style="display: none;"></div>
                        </div>
                    </div>
                    
                    ${supportsColor && isReachable ? `
                    <div class="control-group">
                        <h4>Beliebte Farben</h4>
                        <div class="color-quick-selection">
                            <button class="color-btn" style="background: #ff0000;" onclick="hue.setColor('${id}', '#ff0000', '${type}')" title="Rot"></button>
                            <button class="color-btn" style="background: #00ff00;" onclick="hue.setColor('${id}', '#00ff00', '${type}')" title="Grün"></button>
                            <button class="color-btn" style="background: #0066ff;" onclick="hue.setColor('${id}', '#0066ff', '${type}')" title="Blau"></button>
                            <button class="color-btn" style="background: #ffff00;" onclick="hue.setColor('${id}', '#ffff00', '${type}')" title="Gelb"></button>
                            <button class="color-btn" style="background: #ff00ff;" onclick="hue.setColor('${id}', '#ff00ff', '${type}')" title="Magenta"></button>
                            <button class="color-btn" style="background: #00ffff;" onclick="hue.setColor('${id}', '#00ffff', '${type}')" title="Cyan"></button>
                            <button class="color-btn" style="background: #ff8000;" onclick="hue.setColor('${id}', '#ff8000', '${type}')" title="Orange"></button>
                            <button class="color-btn" style="background: #8000ff;" onclick="hue.setColor('${id}', '#8000ff', '${type}')" title="Violett"></button>
                            <button class="color-btn" style="background: #fff2cc; color: black;" onclick="hue.setColor('${id}', '#fff2cc', '${type}')" title="Warmweiß"></button>
                            <button class="color-btn" style="background: #ffffff; color: black;" onclick="hue.setColor('${id}', '#ffffff', '${type}')" title="Kaltweiß"></button>
                            <button class="color-btn" style="background: #f5f5f5; color: black;" onclick="hue.setColor('${id}', '#f5f5f5', '${type}')" title="Neutralweiß"></button>
                            <button class="color-btn" style="background: #fffacd; color: black;" onclick="hue.setColor('${id}', '#fffacd', '${type}')" title="Tageslicht"></button>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="control-group">
                        <h4>Schnellaktionen</h4>
                        <div class="strobe-speed-control" style="margin-bottom: 8px;">
                            <label for="strobe-speed-${type}-${id}" style="font-size: 12px; color: rgba(255, 255, 255, 0.8);">Geschwindigkeit:</label>
                            <select id="strobe-speed-${type}-${id}" class="strobe-speed-select" onchange="hue.saveStrobeSpeed('${type}', '${id}', this.value)">
                                <option value="fast" ${this.selectedStrobeSpeeds[`${type}_${id}`] === 'fast' || !this.selectedStrobeSpeeds[`${type}_${id}`] ? 'selected' : ''}>Schnell (3-8 Hz)</option>
                                <option value="medium" ${this.selectedStrobeSpeeds[`${type}_${id}`] === 'medium' ? 'selected' : ''}>Mittel (1-3 Hz)</option>
                                <option value="slow" ${this.selectedStrobeSpeeds[`${type}_${id}`] === 'slow' ? 'selected' : ''}>Langsam (0.5-1 Hz)</option>
                                <option value="variable" ${this.selectedStrobeSpeeds[`${type}_${id}`] === 'variable' ? 'selected' : ''}>Variabel (0.5-8 Hz)</option>
                            </select>
                        </div>
                        <div class="effect-controls">
                            <button class="btn warning" onclick="hue.toggleStrobe('${id}', '${type}')" ${!isReachable ? 'disabled' : ''} id="strobe-btn-${type}-${id}">⚡ Strobo</button>
                        </div>
                    </div>
                `;

                return card;
            }
            
            getButtonClass(isOn, isReachable) {
                if (!isReachable) return 'btn-disabled';
                return isOn ? 'btn-on' : 'btn-off';
            }
            
            getButtonText(isOn, isReachable) {
                if (!isReachable) return '❌ Nicht verfügbar';
                return isOn ? '⭕ Ausschalten' : '✅ Einschalten';
            }

            async toggle(id, state, type) {
                const endpoint = type === 'light' ? `/api/lights/${id}/state` : `/api/groups/${id}/action`;
                
                try {
                    await fetch(`${this.baseUrl}${endpoint}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ on: state })
                    });
                    this.init();
                } catch (error) {
                    this.showMessage('Fehler beim Schalten: ' + error.message, 'error');
                }
            }

            setBrightness(id, brightness, type) {
                // Sofortiges UI-Update für bessere Responsiveness
                const key = `brightness_${id}_${type}`;
                
                debouncer.debounce(key, async () => {
                    const endpoint = type === 'light' ? `/api/lights/${id}/state` : `/api/groups/${id}/action`;
                    
                    try {
                        await fetch(`${this.baseUrl}${endpoint}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ bri: parseInt(brightness), transitiontime: 2 })
                        });
                    } catch (error) {
                        this.showMessage('Fehler beim Dimmen: ' + error.message, 'error');
                    }
                }, 250); // 250ms Debounce für Slider
            }

            setColor(id, hexColor, type) {
                const key = `color_${id}_${type}`;
                
                // Track the last selected color for this light/group
                const lightKey = `${type}_${id}`;
                const [hue, sat] = this.hexToHue(hexColor);
                this.lastSelectedColors[lightKey] = { hue, sat, bri: 254 };
                
                // Update active strobe color if this light has strobe running
                if (this.activeStrobes[lightKey]) {
                    this.activeStrobes[lightKey].color = { hue, sat, bri: 254 };
                    // Restart strobe with new color (debounced)
                    debouncer.debounce(`strobe_${lightKey}`, () => {
                        this.restartStrobeWithNewColor(lightKey, type, id);
                    }, 300);
                }
                
                debouncer.debounce(key, async () => {
                    const endpoint = type === 'light' ? `/api/lights/${id}/state` : `/api/groups/${id}/action`;

                    try {
                        await fetch(`${this.baseUrl}${endpoint}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ hue, sat, transitiontime: 3 })
                        });
                    } catch (error) {
                        this.showMessage('Fehler beim Färben: ' + error.message, 'error');
                    }
                }, 200); // 200ms Debounce für Farben
            }

            async activateScene(sceneId, scene) {
                try {
                    await fetch(`${this.baseUrl}/api/scenes/${sceneId}/recall`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ group: '0' })
                    });
                    // Message entfernt - keine störenden Banner mehr
                    setTimeout(() => this.init(), 1000);
                } catch (error) {
                    this.showMessage('Fehler beim Aktivieren der Szene: ' + error.message, 'error');
                }
            }

            async quickEffect(id, effect, type) {
                const data = {
                    type: type,
                    id: id,
                    duration: effect === 'strobe' ? 5 : 15
                };

                try {
                    await fetch(`${this.baseUrl}/api/effects/${effect}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    this.showMessage(`${effect} Effekt gestartet`, 'success');
                    setTimeout(() => this.updateActiveEffects(), 1000);
                } catch (error) {
                    this.showMessage('Fehler beim Starten des Effekts: ' + error.message, 'error');
                }
            }

            async toggleStrobe(id, type) {
                const strobeKey = `${type}_${id}`;
                const button = document.getElementById(`strobe-btn-${type}-${id}`);
                const card = button.closest('.card');
                
                if (this.activeStrobes[strobeKey]) {
                    // Strobo deaktivieren
                    try {
                        await this.stopStrobe(strobeKey);
                        delete this.activeStrobes[strobeKey];
                        if (button) {
                            button.textContent = '⚡ Strobo';
                            button.classList.remove('btn-active');
                        }
                        if (card) {
                            card.classList.remove('strobe-active');
                        }
                        this.showMessage('Strobo deaktiviert', 'info');
                    } catch (error) {
                        this.showMessage('Fehler beim Deaktivieren: ' + error.message, 'error');
                    }
                } else {
                    // Strobo aktivieren
                    try {
                        const selectedColor = this.getSelectedColor(strobeKey);
                        const speed = this.selectedStrobeSpeeds[strobeKey] || 'fast';
                        const frequency = this.getRandomFrequency(speed);
                        
                        const strobeData = {
                            target_type: type,
                            target_id: id,
                            duration: 0, // Permanent
                            frequency: frequency,
                            mode: 'single',
                            brightness: 254,
                            hue: selectedColor.hue,
                            sat: selectedColor.sat,
                            bri: selectedColor.bri
                        };
                        
                        await fetch(`${this.baseUrl}/api/effects/strobe/advanced`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(strobeData)
                        });
                        
                        this.activeStrobes[strobeKey] = {
                            id: id,
                            type: type,
                            color: selectedColor,
                            frequency: frequency
                        };
                        
                        if (button) {
                            button.textContent = '⚡ Strobo AN';
                            button.classList.add('btn-active');
                        }
                        
                        if (card) {
                            card.classList.add('strobe-active');
                        }
                        
                        this.showMessage(`Strobo aktiviert (${frequency.toFixed(1)}Hz)`, 'success');
                        setTimeout(() => this.updateActiveEffects(), 1000);
                    } catch (error) {
                        this.showMessage('Fehler beim Aktivieren: ' + error.message, 'error');
                    }
                }
            }

            async stopStrobe(strobeKey) {
                const strobeData = this.activeStrobes[strobeKey];
                if (strobeData) {
                    const effectId = `advanced_strobe_${strobeKey}_${Math.floor(strobeData.frequency * 10)}`;
                    try {
                        await fetch(`${this.baseUrl}/api/effects/${effectId}/stop`, {
                            method: 'DELETE'
                        });
                    } catch (error) {
                        // Fallback: Try to stop all strobe effects for this light
                        console.warn(`Failed to stop specific strobe ${effectId}, trying emergency stop`);
                        await fetch(`${this.baseUrl}/api/effects/strobe/emergency-stop`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ target_type: strobeData.type, target_id: strobeData.id })
                        });
                    }
                }
            }

            getSelectedColor(lightKey) {
                // Prüfe ob eine Farbe für dieses Licht/Gruppe gespeichert wurde
                if (this.lastSelectedColors[lightKey]) {
                    return this.lastSelectedColors[lightKey];
                }
                
                // Fallback: Standardfarbe (rotes Strobo)
                return { hue: 65000, sat: 254, bri: 254 };
            }

            getRandomFrequency(speed) {
                switch (speed) {
                    case 'fast':
                        return Math.random() * (8 - 3) + 3; // 3-8 Hz
                    case 'medium':
                        return Math.random() * (3 - 1) + 1; // 1-3 Hz
                    case 'slow':
                        return Math.random() * (1 - 0.5) + 0.5; // 0.5-1 Hz
                    case 'variable':
                        return Math.random() * (8 - 0.5) + 0.5; // 0.5-8 Hz
                    default:
                        return Math.random() * (8 - 3) + 3; // Default to fast
                }
            }

            saveStrobeSpeed(type, id, speed) {
                const lightKey = `${type}_${id}`;
                this.selectedStrobeSpeeds[lightKey] = speed;
            }

            async restartStrobeWithNewColor(lightKey, type, id) {
                const strobeData = this.activeStrobes[lightKey];
                if (!strobeData) return;
                
                try {
                    // Stop current strobe
                    await this.stopStrobe(lightKey);
                    
                    // Start new strobe with updated color
                    const newStrobeData = {
                        target_type: type,
                        target_id: id,
                        duration: 0, // Permanent
                        frequency: strobeData.frequency,
                        mode: 'single',
                        brightness: 254,
                        hue: strobeData.color.hue,
                        sat: strobeData.color.sat,
                        bri: strobeData.color.bri
                    };
                    
                    await fetch(`${this.baseUrl}/api/effects/strobe/advanced`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newStrobeData)
                    });
                    
                    this.showMessage(`Strobo-Farbe aktualisiert (${strobeData.frequency.toFixed(1)}Hz)`, 'info');
                } catch (error) {
                    this.showMessage('Fehler beim Farbwechsel: ' + error.message, 'error');
                }
            }

            async quickTimer(id, type) {
                const data = {
                    type: type,
                    id: id,
                    delay: 300, // 5 Minuten
                    action: { on: false }
                };

                try {
                    await fetch(`${this.baseUrl}/api/timer`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                    this.showMessage('Timer erstellt (5 Minuten)', 'success');
                    setTimeout(() => this.updateActiveTimers(), 1000);
                } catch (error) {
                    this.showMessage('Fehler beim Erstellen des Timers: ' + error.message, 'error');
                }
            }

            async updateActiveEffects() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/effects`);
                    const data = await response.json();
                    
                    const container = document.getElementById('effects-list');
                    if (data.active_effects.length === 0) {
                        container.innerHTML = '<div>Keine aktiven Effekte</div>';
                    } else {
                        container.innerHTML = data.active_effects.map(effectId => `
                            <div class="effect-item">
                                <span>${effectId}</span>
                                <button class="btn danger" onclick="hue.stopEffect('${effectId}')">Stoppen</button>
                            </div>
                        `).join('');
                    }
                } catch (error) {
                    console.error('Fehler beim Laden der Effekte:', error);
                }
            }

            async updateActiveTimers() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/timers`);
                    const data = await response.json();
                    
                    const container = document.getElementById('timers-list');
                    const timers = Object.entries(data.active_timers);
                    
                    if (timers.length === 0) {
                        container.innerHTML = '<div>Keine aktiven Timer</div>';
                    } else {
                        container.innerHTML = timers.map(([timerId, timer]) => `
                            <div class="timer-item">
                                <span>${timer.target_type} ${timer.target_id}</span>
                                <button class="btn danger" onclick="hue.cancelTimer('${timerId}')">Abbrechen</button>
                            </div>
                        `).join('');
                    }
                } catch (error) {
                    console.error('Fehler beim Laden der Timer:', error);
                }
            }

            async updatePowerStats() {
                try {
                    const response = await fetch(`${this.baseUrl}/api/power/current`);
                    const data = await response.json();
                    
                    document.getElementById('current-watts').textContent = data.total_watts + 'W';
                    document.getElementById('active-lights-count').textContent = data.active_lights;
                    document.getElementById('monthly-estimate').textContent = data.estimated_monthly_kwh + ' kWh';
                    document.getElementById('monthly-cost').textContent = data.estimated_monthly_cost_eur + '€';
                    
                    document.getElementById('current-power').textContent = 
                        `💡 ${data.active_lights} Lichter • ⚡ ${data.total_watts}W • 💰 ~${data.estimated_monthly_cost_eur}€/Monat`;

                    // Light details
                    const detailsContainer = document.getElementById('light-power-details');
                    detailsContainer.innerHTML = data.light_details.map(light => `
                        <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                            <span>${light.name}${!light.reachable ? ' ⚠️ (nicht erreichbar)' : ''}</span>
                            <span>${light.watts}W (${Math.round(light.brightness/254*100)}%)</span>
                        </div>
                    `).join('');
                    
                    // Don't update charts here - it's handled by tab switching
                    // This prevents duplicate chart updates
                    
                } catch (error) {
                    console.error('Fehler beim Laden der Power Stats:', error);
                }
            }

            async updatePowerCharts() {
                // This method is now deprecated - power charts are handled by switchPowerView
                // Keeping it empty to avoid breaking existing calls
                console.log('updatePowerCharts called - now handled by switchPowerView');
            }

            // Deprecated - use renderDetailedChart instead
            renderPowerChart(hourlyData) {
                console.warn('renderPowerChart is deprecated - data will be rendered through switchPowerView');
            }

            renderTopConsumers(consumers) {
                const container = document.getElementById('top-consumers');
                if (!consumers || consumers.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Noch keine Daten vorhanden</div>';
                    return;
                }
                
                container.innerHTML = consumers.map(consumer => `
                    <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <span>${consumer.light_name}</span>
                        <span>${parseFloat(consumer.total_kwh).toFixed(3)} kWh (⌀ ${parseFloat(consumer.avg_watts).toFixed(1)}W)</span>
                    </div>
                `).join('');
            }

            // Erweiterte Power Charts
            currentPowerView = 'today';
            powerCharts = {};
            loadingStates = {}; // Track loading states to prevent concurrent requests

            async switchPowerView(view) {
                // Prevent concurrent requests for the same view
                if (this.loadingStates[view]) {
                    console.log('🚫 Already loading data for view:', view);
                    return;
                }
                
                this.currentPowerView = view;
                this.loadingStates[view] = true;
                
                try {
                    // Update tab selection
                    document.querySelectorAll('[data-view]').forEach(tab => {
                        tab.classList.toggle('active', tab.dataset.view === view);
                    });
                    
                    // Hide all special chart sections
                    document.getElementById('weekday-analysis').style.display = 'none';
                    document.getElementById('monthly-comparison').style.display = 'none';
                    document.getElementById('seasonal-comparison').style.display = 'none';
                    
                    switch (view) {
                        case 'today':
                        case 'week':
                        case 'month':
                            await this.loadDetailedPowerData(view);
                            break;
                        case 'year':
                            await this.loadMonthlyComparison();
                            break;
                        case 'weekday':
                            await this.loadWeekdayAnalysis();
                            break;
                        case 'seasonal':
                            await this.loadSeasonalComparison();
                            break;
                    }
                } catch (error) {
                    console.error('Error switching power view:', error);
                } finally {
                    // Always clear loading state
                    this.loadingStates[view] = false;
                }
            }

            async loadDetailedPowerData(timeframe, retryCount = 0) {
                const maxRetries = 2;
                
                try {
                    console.log('🔄 Loading detailed power data for:', timeframe, retryCount > 0 ? `(retry ${retryCount})` : '');
                    
                    const response = await fetch(`/api/power/detailed/${timeframe}`, {
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    let data;
                    
                    try {
                        data = JSON.parse(text);
                    } catch (parseError) {
                        console.error('JSON parse error:', parseError, 'Raw response:', text.substring(0, 200));
                        throw new Error('Invalid JSON response from server');
                    }
                    
                    console.log('📡 API response:', { 
                        timeframe, 
                        detailedDataLength: data.detailed_data?.length,
                        topLightsLength: data.top_lights?.length,
                        sample: data.detailed_data?.slice(0, 2),
                        hasDetailedData: !!data.detailed_data,
                        hasTopLights: !!data.top_lights
                    });
                    
                    // Validate response structure
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid data structure received from API');
                    }
                    
                    // Check if we got incomplete data and should retry
                    if ((!data.detailed_data || !Array.isArray(data.detailed_data)) && retryCount < maxRetries) {
                        console.warn(`⚠️ Incomplete data received, retrying... (${retryCount + 1}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
                        return this.loadDetailedPowerData(timeframe, retryCount + 1);
                    }
                    
                    // Update chart title
                    const titles = {
                        'today': 'Verbrauchsverlauf - Heute (minütlich)',
                        'week': 'Verbrauchsverlauf - Diese Woche',
                        'month': 'Verbrauchsverlauf - Dieser Monat'
                    };
                    document.getElementById('chart-title').textContent = titles[timeframe];
                    
                    // Render main chart with fallback
                    if (data.detailed_data && Array.isArray(data.detailed_data) && data.detailed_data.length > 0) {
                        this.renderDetailedChart(data.detailed_data, timeframe);
                    } else {
                        console.warn('⚠️ No detailed data available for chart');
                        this.showNoDataMessage('powerChart', 'Keine Daten für diesen Zeitraum verfügbar');
                    }
                    
                    // Update top consumers with fallback
                    if (data.top_lights && Array.isArray(data.top_lights)) {
                        this.renderTopConsumers(data.top_lights);
                    } else {
                        console.warn('⚠️ No top lights data available');
                        document.getElementById('top-consumers').innerHTML = '<div class="status-item"><div class="status-label">Keine Verbraucher-Daten verfügbar</div></div>';
                    }
                    
                    document.getElementById('top-consumer-timeframe').textContent = 
                        timeframe === 'today' ? 'heute' : 
                        timeframe === 'week' ? 'diese Woche' : 'diesen Monat';
                    
                    // Update detailed stats with fallback
                    if (data.detailed_data && Array.isArray(data.detailed_data) && data.detailed_data.length > 0) {
                        this.renderDetailedStats(data.detailed_data, timeframe);
                    } else {
                        document.getElementById('detailed-stats').innerHTML = '<div class="status-item"><div class="status-label">Keine Statistiken verfügbar</div></div>';
                    }
                    
                } catch (error) {
                    console.error('Error loading detailed power data:', error);
                    
                    // Show user-friendly error message
                    this.showNoDataMessage('powerChart', `Fehler beim Laden der Daten: ${error.message}`);
                    document.getElementById('top-consumers').innerHTML = '<div class="status-item error"><div class="status-label">Fehler beim Laden</div></div>';
                    document.getElementById('detailed-stats').innerHTML = '<div class="status-item error"><div class="status-label">Fehler beim Laden</div></div>';
                }
            }

            renderDetailedChart(data, timeframe) {
                console.log('🔄 renderDetailedChart called with:', { timeframe, dataLength: data?.length, data: data?.slice(0, 3) });
                
                const ctx = document.getElementById('powerChart').getContext('2d');
                
                // Unified chart destruction - only check Chart.js registry
                const existingChart = Chart.getChart('powerChart');
                if (existingChart) {
                    console.log('🗑️ Destroying existing chart');
                    existingChart.destroy();
                }
                
                // Clear both references to prevent confusion
                this.powerChart = null;
                this.powerCharts.main = null;
                
                // Data validation
                if (!data || data.length === 0) {
                    console.warn('⚠️ No data received for chart rendering');
                    return;
                }
                
                const labels = data.map(item => item.time);
                const avgData = data.map(item => parseFloat(item.avg_watts));
                const maxData = data.map(item => parseFloat(item.max_watts));
                const minData = data.map(item => parseFloat(item.min_watts));
                
                console.log('📊 Chart data processed:', { 
                    labels: labels.slice(0, 5), 
                    avgData: avgData.slice(0, 5),
                    maxData: maxData.slice(0, 5),
                    minData: minData.slice(0, 5)
                });
                
                this.powerCharts.main = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Durchschnitt',
                                data: avgData,
                                borderColor: 'rgba(104, 141, 177, 1)',
                                backgroundColor: 'rgba(104, 141, 177, 0.1)',
                                fill: true,
                                tension: 0.3,
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 4
                            },
                            {
                                label: 'Maximum',
                                data: maxData,
                                borderColor: 'rgba(225, 97, 98, 1)',
                                backgroundColor: 'rgba(225, 97, 98, 0.1)',
                                fill: false,
                                tension: 0.3,
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 4
                            },
                            {
                                label: 'Minimum',
                                data: minData,
                                borderColor: 'rgba(156, 182, 143, 1)',
                                backgroundColor: 'rgba(156, 182, 143, 0.1)',
                                fill: '-1',
                                tension: 0.3,
                                borderWidth: 2,
                                pointRadius: 0,
                                pointHoverRadius: 4
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        elements: {
                            line: {
                                borderColor: 'rgba(104, 141, 177, 1)' // Fallback line color
                            },
                            point: {
                                borderColor: 'rgba(104, 141, 177, 1)',
                                backgroundColor: 'rgba(104, 141, 177, 1)'
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                // Dynamische Skalierung
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + 'W';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Leistung (W)',
                                    color: 'rgba(255, 255, 255, 0.8)'
                                }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    maxTicksLimit: timeframe === 'today' ? 24 : 20
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}W`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            async loadWeekdayAnalysis() {
                document.getElementById('weekday-analysis').style.display = 'block';
                document.getElementById('chart-title').textContent = 'Wochentags-Analyse';
                
                try {
                    const response = await fetch('/api/power/weekly');
                    const data = await response.json();
                    
                    if (data && data.weekday_summary) {
                        this.renderWeekdayChart(data.weekday_summary);
                    } else {
                        console.warn('⚠️ No weekday_summary data received');
                    }
                    
                    if (data && data.weekday_hourly) {
                        this.renderWeekdayHeatmap(data.weekday_hourly);
                    } else {
                        console.warn('⚠️ No weekday_hourly data received');
                    }
                    
                } catch (error) {
                    console.error('Error loading weekday analysis:', error);
                }
            }

            renderWeekdayChart(weekdayData) {
                const ctx = document.getElementById('weekdayChart').getContext('2d');
                
                if (this.powerCharts.weekday) {
                    this.powerCharts.weekday.destroy();
                }
                
                // Data validation
                if (!weekdayData || !Array.isArray(weekdayData) || weekdayData.length === 0) {
                    console.warn('⚠️ No weekday data received for chart rendering');
                    return;
                }
                
                const labels = weekdayData.map(item => item.weekday);
                const avgData = weekdayData.map(item => parseFloat(item.avg_watts));
                const maxData = weekdayData.map(item => parseFloat(item.max_watts));
                const kwhData = weekdayData.map(item => parseFloat(item.total_kwh));
                
                // Get consistent colors
                const colors = this.getChartColors();
                
                this.powerCharts.weekday = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Durchschnitt (W)',
                                data: avgData,
                                backgroundColor: colors.blueAlpha(0.8),
                                yAxisID: 'y'
                            },
                            {
                                label: 'Total kWh',
                                data: kwhData,
                                type: 'line',
                                borderColor: colors.green,
                                backgroundColor: colors.green,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: true,
                                max: 100,
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + 'W';
                                    }
                                },
                                title: { display: true, text: 'Leistung (W)', color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                beginAtZero: true,
                                max: 5,
                                grid: { drawOnChartArea: false },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + ' kWh';
                                    }
                                },
                                title: { display: true, text: 'Energie (kWh)', color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'rgba(255, 255, 255, 0.8)' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: 'rgba(255, 255, 255, 0.8)' } }
                        }
                    }
                });
            }

            renderWeekdayHeatmap(weekdayHourlyData) {
                const ctx = document.getElementById('weekdayHeatmap').getContext('2d');
                
                // Destroy existing chart
                if (this.powerCharts.weekdayHeatmap) {
                    this.powerCharts.weekdayHeatmap.destroy();
                }
                
                // Data validation
                if (!weekdayHourlyData || weekdayHourlyData.length === 0) {
                    console.warn('⚠️ No weekday hourly data received for heatmap');
                    return;
                }
                
                // Transform data for heatmap
                const weekdays = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
                const hours = Array.from({length: 24}, (_, i) => i);
                
                // Get consistent colors
                const colors = this.getChartColors();
                
                // Create matrix data
                const datasets = [{
                    label: 'Verbrauch (W)',
                    data: weekdayHourlyData.map(item => ({
                        x: item.hour,
                        y: weekdays.indexOf(item.weekday),
                        v: parseFloat(item.avg_watts)
                    })),
                    backgroundColor: function(context) {
                        const value = context.parsed.v;
                        const alpha = Math.min(value / 100, 1); // Normalize to 0-1 range
                        // Use hardcoded color for context function, as closure doesn't work here
                        const rgb = '104, 141, 177'; // --accent-blue equivalent
                        return `rgba(${rgb}, ${alpha})`;
                    },
                    borderColor: colors.blueAlpha(0.8),
                    borderWidth: 1
                }];
                
                this.powerCharts.weekdayHeatmap = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                min: 0,
                                max: 23,
                                ticks: {
                                    stepSize: 1,
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + ':00';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                title: { display: true, text: 'Stunde', color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            y: {
                                type: 'linear',
                                min: -0.5,
                                max: 6.5,
                                ticks: {
                                    stepSize: 1,
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return weekdays[value] || '';
                                    }
                                },
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                title: { display: true, text: 'Wochentag', color: 'rgba(255, 255, 255, 0.8)' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: 'rgba(255, 255, 255, 0.8)' } },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const point = context[0];
                                        return `${weekdays[point.parsed.y]} ${point.parsed.x}:00`;
                                    },
                                    label: function(context) {
                                        return `Verbrauch: ${context.parsed.v.toFixed(1)}W`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            async loadMonthlyComparison() {
                document.getElementById('monthly-comparison').style.display = 'block';
                document.getElementById('chart-title').textContent = 'Monatsvergleich';
                
                try {
                    const response = await fetch('/api/power/monthly');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    const data = await response.json();
                    
                    if (data && data.monthly_summary) {
                        this.renderMonthlyChart(data.monthly_summary);
                    } else {
                        console.warn('⚠️ No monthly_summary data received');
                        // Show a message to user that monthly data is not available
                        const ctx = document.getElementById('monthlyChart').getContext('2d');
                        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('Keine monatlichen Daten verfügbar', ctx.canvas.width/2, ctx.canvas.height/2);
                    }
                    
                } catch (error) {
                    console.error('Error loading monthly comparison:', error);
                    // Show error message to user
                    const ctx = document.getElementById('monthlyChart').getContext('2d');
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('Fehler beim Laden der monatlichen Daten', ctx.canvas.width/2, ctx.canvas.height/2);
                }
            }

            renderMonthlyChart(monthlyData) {
                const ctx = document.getElementById('monthlyChart').getContext('2d');
                
                if (this.powerCharts.monthly) {
                    this.powerCharts.monthly.destroy();
                }
                
                // Data validation
                if (!monthlyData || !Array.isArray(monthlyData) || monthlyData.length === 0) {
                    console.warn('⚠️ No monthly data received for chart rendering');
                    return;
                }
                
                console.log('📊 Monthly data received:', monthlyData);
                
                const labels = monthlyData.map(item => item.month);
                const kwhData = monthlyData.map(item => parseFloat(item.total_kwh));
                const costData = monthlyData.map(item => parseFloat(item.cost_eur));
                const avgWatts = monthlyData.map(item => parseFloat(item.avg_watts));
                
                // Get consistent colors
                const colors = this.getChartColors();
                
                this.powerCharts.monthly = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Energie (kWh)',
                                data: kwhData,
                                backgroundColor: colors.blueAlpha(0.8),
                                yAxisID: 'y'
                            },
                            {
                                label: 'Kosten (€)',
                                data: costData,
                                type: 'line',
                                borderColor: colors.red,
                                backgroundColor: colors.red,
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: true,
                                max: 100,
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + ' kWh';
                                    }
                                },
                                title: { display: true, text: 'Energie (kWh)', color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            y1: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                beginAtZero: true,
                                max: 50,
                                grid: { drawOnChartArea: false },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + ' €';
                                    }
                                },
                                title: { display: true, text: 'Kosten (€)', color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value, index) {
                                        // Convert YYYY-MM format to readable month name
                                        const month = labels[index];
                                        if (month) {
                                            const [year, monthNum] = month.split('-');
                                            const monthNames = [
                                                'Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun',
                                                'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'
                                            ];
                                            return `${monthNames[parseInt(monthNum) - 1]} ${year}`;
                                        }
                                        return month;
                                    }
                                },
                                title: { 
                                    display: true, 
                                    text: 'Monat', 
                                    color: 'rgba(255, 255, 255, 0.8)' 
                                }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: 'rgba(255, 255, 255, 0.8)' } }
                        }
                    }
                });
            }

            async loadSeasonalComparison() {
                document.getElementById('seasonal-comparison').style.display = 'block';
                document.getElementById('chart-title').textContent = 'Sommer vs. Winter Verbrauch';
                
                try {
                    const response = await fetch('/api/power/seasonal');
                    const data = await response.json();
                    
                    this.renderSeasonalPieChart(data.seasonal_comparison);
                    this.renderSeasonalHourlyChart(data.seasonal_hourly);
                    
                } catch (error) {
                    console.error('Error loading seasonal comparison:', error);
                }
            }

            renderSeasonalPieChart(seasonalData) {
                const ctx = document.getElementById('seasonalPieChart').getContext('2d');
                
                if (this.powerCharts.seasonalPie) {
                    this.powerCharts.seasonalPie.destroy();
                }
                
                const labels = seasonalData.map(item => item.season);
                const kwhData = seasonalData.map(item => parseFloat(item.total_kwh));
                
                // Get consistent colors
                const colors = this.getChartColors();
                
                this.powerCharts.seasonalPie = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: kwhData,
                            backgroundColor: [
                                colors.greenAlpha(0.8),   // Sommer - grün
                                colors.blueAlpha(0.8)     // Winter - blau
                            ],
                            borderColor: [
                                colors.green,
                                colors.blue
                            ],
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        plugins: {
                            legend: { 
                                labels: { color: 'rgba(255, 255, 255, 0.8)' },
                                position: 'bottom'
                            },
                            title: {
                                display: true,
                                text: 'Energieverbrauch nach Jahreszeit',
                                color: 'rgba(255, 255, 255, 0.8)'
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.parsed || 0;
                                        return `${label}: ${value.toFixed(1)} kWh`;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            renderSeasonalHourlyChart(seasonalHourlyData) {
                const ctx = document.getElementById('seasonalHourlyChart').getContext('2d');
                
                if (this.powerCharts.seasonalHourly) {
                    this.powerCharts.seasonalHourly.destroy();
                }
                
                // Gruppiere Daten nach Jahreszeit
                const summerData = seasonalHourlyData
                    .filter(item => item.season === 'Sommer')
                    .sort((a, b) => a.hour - b.hour);
                const winterData = seasonalHourlyData
                    .filter(item => item.season === 'Winter')
                    .sort((a, b) => a.hour - b.hour);
                
                const hours = Array.from({length: 24}, (_, i) => `${i}:00`);
                
                // Get consistent colors
                const colors = this.getChartColors();
                
                this.powerCharts.seasonalHourly = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: hours,
                        datasets: [
                            {
                                label: 'Sommer',
                                data: hours.map(hour => {
                                    const h = parseInt(hour);
                                    const found = summerData.find(item => item.hour === h);
                                    return found ? parseFloat(found.avg_watts) : 0;
                                }),
                                borderColor: colors.green,
                                backgroundColor: colors.greenAlpha(0.1),
                                fill: false,
                                tension: 0.3
                            },
                            {
                                label: 'Winter',
                                data: hours.map(hour => {
                                    const h = parseInt(hour);
                                    const found = winterData.find(item => item.hour === h);
                                    return found ? parseFloat(found.avg_watts) : 0;
                                }),
                                borderColor: colors.blue,
                                backgroundColor: colors.blueAlpha(0.1),
                                fill: false,
                                tension: 0.3
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                // Dynamische Skalierung
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + 'W';
                                    }
                                },
                                title: { display: true, text: 'Leistung (W)', color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { color: 'rgba(255, 255, 255, 0.8)' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: 'rgba(255, 255, 255, 0.8)' } },
                            title: {
                                display: true,
                                text: 'Stundenvergleich Sommer vs. Winter',
                                color: 'rgba(255, 255, 255, 0.8)'
                            }
                        }
                    }
                });
            }

            renderDetailedStats(data, timeframe) {
                const statsContainer = document.getElementById('detailed-stats');
                
                if (!data || data.length === 0) {
                    statsContainer.innerHTML = '<div class="status-item"><div class="status-label">Keine Daten verfügbar</div></div>';
                    return;
                }
                
                // Filter out zero values for more meaningful statistics
                const nonZeroData = data.filter(item => parseFloat(item.avg_watts) > 0);
                const activeReadings = nonZeroData.length;
                
                const totalReadings = data.length;
                const avgWatts = data.reduce((sum, item) => sum + parseFloat(item.avg_watts), 0) / totalReadings;
                const maxWatts = Math.max(...data.map(item => parseFloat(item.max_watts)));
                const minWatts = Math.min(...data.map(item => parseFloat(item.min_watts)));
                
                // Improved kWh calculation based on timeframe
                let totalKwh = 0;
                if (timeframe === 'today') {
                    // For today: each data point represents 1 minute, so divide by 60 to get hours
                    totalKwh = data.reduce((sum, item) => sum + parseFloat(item.avg_watts), 0) / 60 / 1000;
                } else if (timeframe === 'week') {
                    // For week: each data point represents 1 hour
                    totalKwh = data.reduce((sum, item) => sum + parseFloat(item.avg_watts), 0) / 1000;
                } else if (timeframe === 'month') {
                    // For month: each data point represents 1 day (24 hours)
                    totalKwh = data.reduce((sum, item) => sum + parseFloat(item.avg_watts), 0) * 24 / 1000;
                }
                
                const labels = {
                    'today': 'heute',
                    'week': 'diese Woche',
                    'month': 'diesen Monat'
                };
                
                const activePercentage = (activeReadings / totalReadings * 100);
                const avgActiveWatts = activeReadings > 0 ? 
                    nonZeroData.reduce((sum, item) => sum + parseFloat(item.avg_watts), 0) / activeReadings : 0;
                
                // Enhanced cost calculations with different rates
                const costRates = {
                    day: 0.32,    // Day rate (6:00-22:00)
                    night: 0.25,  // Night rate (22:00-6:00)
                    weekend: 0.28 // Weekend rate
                };
                
                // Calculate costs based on actual consumption
                const baseCost = totalKwh * 0.30; // Basic calculation
                const premiumCost = totalKwh * costRates.day; // Premium rate
                const economyCost = totalKwh * costRates.night; // Economy rate
                
                // Calculate cost projections
                let costProjections = {};
                if (timeframe === 'today') {
                    costProjections = {
                        week: baseCost * 7,
                        month: baseCost * 30,
                        year: baseCost * 365
                    };
                } else if (timeframe === 'week') {
                    costProjections = {
                        month: baseCost * 4.33, // Average weeks per month
                        year: baseCost * 52
                    };
                } else if (timeframe === 'month') {
                    costProjections = {
                        year: baseCost * 12
                    };
                }
                
                // Erweiterte Berechnungen für coole Insights
                const efficiency = maxWatts > 0 ? (avgWatts / maxWatts * 100) : 0;
                const co2Savings = (9 - avgWatts) * totalReadings / 60 * 0.401; // 401g CO2/kWh Deutschland
                const treesEquivalent = co2Savings / 22; // 22kg CO2 pro Baum/Jahr
                const phoneCharges = totalKwh * 1000 / 15; // 15Wh pro Smartphone-Ladung
                const ledBulbHours = totalKwh / 0.009; // 9W LED Glühbirne
                
                // Compare with typical household consumption
                const typicalHouseholdDaily = 10; // kWh per day
                const savingsVsTypical = timeframe === 'today' ? 
                    ((typicalHouseholdDaily - totalKwh) / typicalHouseholdDaily * 100) : 
                    timeframe === 'week' ? 
                    ((typicalHouseholdDaily * 7 - totalKwh) / (typicalHouseholdDaily * 7) * 100) :
                    ((typicalHouseholdDaily * 30 - totalKwh) / (typicalHouseholdDaily * 30) * 100);
                
                // Tageszeiten-Analyse
                const hourlyData = {};
                data.forEach(item => {
                    const hour = parseInt(item.time.split(':')[0]);
                    if (!hourlyData[hour]) hourlyData[hour] = [];
                    hourlyData[hour].push(parseFloat(item.avg_watts));
                });
                
                const peakHour = Object.keys(hourlyData).reduce((peak, hour) => {
                    const avgHour = hourlyData[hour].reduce((sum, w) => sum + w, 0) / hourlyData[hour].length;
                    const peakAvg = hourlyData[peak] ? hourlyData[peak].reduce((sum, w) => sum + w, 0) / hourlyData[peak].length : 0;
                    return avgHour > peakAvg ? hour : peak;
                }, '0');
                
                const peakHourAvg = hourlyData[peakHour] ? 
                    (hourlyData[peakHour].reduce((sum, w) => sum + w, 0) / hourlyData[peakHour].length).toFixed(1) : '0.0';
                
                // Status-Emojis basierend auf Effizienz
                const getEfficiencyEmoji = (eff) => {
                    if (eff > 80) return '🔥';
                    if (eff > 60) return '⚡';
                    if (eff > 40) return '💡';
                    if (eff > 20) return '🌱';
                    return '💤';
                };
                
                const getCostEmoji = (cost) => {
                    if (cost < 1) return '💰';
                    if (cost < 5) return '💳';
                    if (cost < 10) return '💸';
                    return '🔥💸';
                };
                
                const getSavingsEmoji = (savings) => {
                    if (savings > 80) return '🌟';
                    if (savings > 60) return '🎯';
                    if (savings > 40) return '👍';
                    if (savings > 20) return '💚';
                    return '⚠️';
                };
                
                statsContainer.innerHTML = `
                    <div class="status-item highlight">
                        <div class="status-value">${getEfficiencyEmoji(efficiency)} ${efficiency.toFixed(1)}%</div>
                        <div class="status-label">Effizienz-Score</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">⚡ ${avgWatts.toFixed(1)}W</div>
                        <div class="status-label">Ø Verbrauch ${labels[timeframe] || ''}</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">🔥 ${maxWatts.toFixed(1)}W</div>
                        <div class="status-label">Spitzenlast</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">💡 ${avgActiveWatts.toFixed(1)}W</div>
                        <div class="status-label">Ø wenn aktiv</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">⚡ ${totalKwh.toFixed(3)} kWh</div>
                        <div class="status-label">Gesamtverbrauch ${labels[timeframe] || ''}</div>
                    </div>
                    <div class="status-item highlight">
                        <div class="status-value">${getCostEmoji(baseCost)} ${baseCost.toFixed(2)}€</div>
                        <div class="status-label">Kosten ${labels[timeframe] || ''} (0,30€/kWh)</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">💰 ${economyCost.toFixed(2)}€</div>
                        <div class="status-label">Nachttarif (0,25€/kWh)</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">💳 ${premiumCost.toFixed(2)}€</div>
                        <div class="status-label">Tagtarif (0,32€/kWh)</div>
                    </div>
                    ${timeframe === 'today' ? `
                    <div class="status-item eco">
                        <div class="status-value">📈 ${costProjections.week.toFixed(2)}€</div>
                        <div class="status-label">Hochrechnung Woche</div>
                    </div>
                    <div class="status-item eco">
                        <div class="status-value">📈 ${costProjections.month.toFixed(2)}€</div>
                        <div class="status-label">Hochrechnung Monat</div>
                    </div>
                    <div class="status-item eco">
                        <div class="status-value">📈 ${costProjections.year.toFixed(2)}€</div>
                        <div class="status-label">Hochrechnung Jahr</div>
                    </div>
                    ` : ''}
                    ${timeframe === 'week' ? `
                    <div class="status-item eco">
                        <div class="status-value">📈 ${costProjections.month.toFixed(2)}€</div>
                        <div class="status-label">Hochrechnung Monat</div>
                    </div>
                    <div class="status-item eco">
                        <div class="status-value">📈 ${costProjections.year.toFixed(2)}€</div>
                        <div class="status-label">Hochrechnung Jahr</div>
                    </div>
                    ` : ''}
                    ${timeframe === 'month' ? `
                    <div class="status-item eco">
                        <div class="status-value">📈 ${costProjections.year.toFixed(2)}€</div>
                        <div class="status-label">Hochrechnung Jahr</div>
                    </div>
                    ` : ''}
                    <div class="status-item highlight">
                        <div class="status-value">${getSavingsEmoji(savingsVsTypical)} ${savingsVsTypical.toFixed(1)}%</div>
                        <div class="status-label">Einsparung vs. Ø Haushalt</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">🕐 ${peakHour}:00</div>
                        <div class="status-label">Peak-Zeit (${peakHourAvg}W)</div>
                    </div>
                    <div class="status-item">
                        <div class="status-value">📊 ${activePercentage.toFixed(1)}%</div>
                        <div class="status-label">Aktivitätszeit</div>
                    </div>
                    <div class="status-item eco">
                        <div class="status-value">🌱 ${co2Savings.toFixed(1)}g</div>
                        <div class="status-label">CO₂ gespart vs. Halogen</div>
                    </div>
                    <div class="status-item eco">
                        <div class="status-value">🌳 ${treesEquivalent.toFixed(2)}</div>
                        <div class="status-label">Baum-Äquivalent</div>
                    </div>
                    <div class="status-item fun">
                        <div class="status-value">📱 ${phoneCharges.toFixed(0)}x</div>
                        <div class="status-label">Smartphone-Ladungen</div>
                    </div>
                    <div class="status-item fun">
                        <div class="status-value">💡 ${ledBulbHours.toFixed(0)}h</div>
                        <div class="status-label">LED-Brenndauer</div>
                    </div>
                `;
            }

            getChartColors() {
                return {
                    blue: 'rgba(104, 141, 177, 1)',
                    blueAlpha: (alpha) => `rgba(104, 141, 177, ${alpha})`,
                    red: 'rgba(225, 97, 98, 1)',
                    redAlpha: (alpha) => `rgba(225, 97, 98, ${alpha})`,
                    green: 'rgba(156, 182, 143, 1)',
                    greenAlpha: (alpha) => `rgba(156, 182, 143, ${alpha})`,
                    yellow: 'rgba(255, 206, 84, 1)',
                    yellowAlpha: (alpha) => `rgba(255, 206, 84, ${alpha})`,
                    purple: 'rgba(153, 102, 255, 1)',
                    purpleAlpha: (alpha) => `rgba(153, 102, 255, ${alpha})`,
                    orange: 'rgba(255, 159, 64, 1)',
                    orangeAlpha: (alpha) => `rgba(255, 159, 64, ${alpha})`
                };
            }
            
            showNoDataMessage(canvasId, message) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(message, canvas.width / 2, canvas.height / 2);
            }

            async loadLampSelection() {
                try {
                    const response = await fetch('/api/lights');
                    const lightsObj = await response.json();
                    
                    console.log('📡 Raw lights response:', lightsObj);
                    
                    // Convert lights object to array - handle all lights regardless of status
                    const lights = Object.entries(lightsObj)
                        .map(([id, light]) => ({
                            id: id,
                            name: light.name || `Lampe ${id}`,
                            state: light.state,
                            type: light.type,
                            modelid: light.modelid,
                            reachable: light.state?.reachable !== false, // Include even unreachable lights
                            ...light
                        }))
                        .sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically
                    
                    console.log(`🔍 Found ${lights.length} lights for selection:`, lights.map(l => `${l.name} (ID: ${l.id}, reachable: ${l.reachable})`));
                    
                    const container = document.getElementById('lamp-selection');
                    container.innerHTML = lights.map(light => {
                        const isUnreachable = !light.reachable;
                        const statusIcon = isUnreachable ? '⚠️' : '💡';
                        const statusText = isUnreachable ? ' (nicht erreichbar)' : '';
                        
                        return `
                            <label style="display: flex; align-items: center; padding: var(--spacing-2); cursor: pointer; ${isUnreachable ? 'opacity: 0.7;' : ''}">
                                <input type="checkbox" 
                                       class="lamp-checkbox" 
                                       value="${light.id}" 
                                       data-name="${light.name}"
                                       style="margin-right: var(--spacing-2);">
                                <span>${statusIcon} ${light.name}${statusText}</span>
                            </label>
                        `;
                    }).join('');
                    
                    console.log(`✅ Lamp selection loaded with ${lights.length} lamps`);
                    
                } catch (error) {
                    console.error('Error loading lamp selection:', error);
                    document.getElementById('lamp-selection').innerHTML = '<div style="color: var(--accent-red); padding: var(--spacing-3);">Fehler beim Laden der Lampen</div>';
                }
            }

            async updateIndividualLampChart() {
                const checkboxes = document.querySelectorAll('.lamp-checkbox:checked');
                const selectedLamps = Array.from(checkboxes).map(cb => ({
                    id: cb.value,
                    name: cb.dataset.name
                }));
                
                if (selectedLamps.length === 0) {
                    this.showNoDataMessage('individualLampChart', 'Bitte wählen Sie mindestens eine Lampe aus');
                    return;
                }
                
                const timeframe = document.getElementById('individual-lamp-timeframe').value;
                
                try {
                    // Fetch data for selected lamps
                    const promises = selectedLamps.map(lamp => 
                        fetch(`/api/power/lamp/${lamp.id}/${timeframe}`)
                            .then(res => res.json())
                            .then(data => ({ ...lamp, data: data }))
                            .catch(err => ({ ...lamp, data: null, error: err }))
                    );
                    
                    const results = await Promise.all(promises);
                    this.renderIndividualLampChart(results, timeframe);
                    
                } catch (error) {
                    console.error('Error updating individual lamp chart:', error);
                    this.showNoDataMessage('individualLampChart', 'Fehler beim Laden der Daten');
                }
            }

            renderIndividualLampChart(lampData, timeframe) {
                const ctx = document.getElementById('individualLampChart').getContext('2d');
                
                if (this.powerCharts.individual) {
                    this.powerCharts.individual.destroy();
                }
                
                // Filter out lamps with no data
                const validLamps = lampData.filter(lamp => lamp.data && lamp.data.detailed_data);
                
                if (validLamps.length === 0) {
                    this.showNoDataMessage('individualLampChart', 'Keine Daten für ausgewählte Lampen verfügbar');
                    return;
                }
                
                // Get colors for each lamp
                const colors = this.getChartColors();
                const colorKeys = Object.keys(colors).filter(key => !key.includes('Alpha'));
                
                // Prepare datasets
                const datasets = validLamps.map((lamp, index) => {
                    const color = colors[colorKeys[index % colorKeys.length]];
                    const colorAlpha = colors[colorKeys[index % colorKeys.length] + 'Alpha'];
                    
                    return {
                        label: lamp.name,
                        data: lamp.data.detailed_data.map(item => ({
                            x: item.time,
                            y: parseFloat(item.avg_watts)
                        })),
                        borderColor: color,
                        backgroundColor: colorAlpha ? colorAlpha(0.1) : color,
                        fill: false,
                        tension: 0.3,
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    };
                });
                
                // Get labels from first lamp's data
                const labels = validLamps[0].data.detailed_data.map(item => item.time);
                
                this.powerCharts.individual = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    callback: function(value) {
                                        return value + 'W';
                                    }
                                },
                                title: {
                                    display: true,
                                    text: 'Leistung (W)',
                                    color: 'rgba(255, 255, 255, 0.8)'
                                }
                            },
                            x: {
                                grid: { color: 'rgba(255, 255, 255, 0.1)' },
                                ticks: { 
                                    color: 'rgba(255, 255, 255, 0.8)',
                                    maxTicksLimit: timeframe === 'today' ? 24 : 20
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                labels: { color: 'rgba(255, 255, 255, 0.8)' }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}W`;
                                    }
                                }
                            }
                        }
                    }
                });
            }


            startLiveUpdates() {
                // Update effects and timers every 1 minute
                this.effectsUpdateInterval = setInterval(() => {
                    this.updateActiveEffects();
                    this.updateActiveTimers();
                }, 60000);

                // Update light states every 5 seconds for all tabs
                this.updateInterval = setInterval(() => {
                    this.refreshCurrentTab();
                }, 5000);
                
                // Update power stats every 30 seconds
                this.powerUpdateInterval = setInterval(() => {
                    this.updatePowerStats();
                }, 30000);
            }

            async refreshCurrentTab() {
                try {
                    if (this.activeTab === 'lights') {
                        await this.loadLights();
                    } else if (this.activeTab === 'groups') {
                        await this.loadGroups();
                    } else if (this.activeTab === 'scenes') {
                        await this.loadScenes();
                    }
                } catch (error) {
                    console.error('Error refreshing tab:', error);
                }
            }

            addCardAnimation(card) {
                // Hover glow effect removed as requested
                // No mouse event listeners added
            }

            // Helper functions
            hueToHex(hue, sat) {
                const h = (hue || 0) / 65535 * 360;
                const s = (sat || 0) / 254;
                const v = 1;

                const c = v * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = v - c;

                let r, g, b;
                if (h >= 0 && h < 60) { r = c; g = x; b = 0; }
                else if (h >= 60 && h < 120) { r = x; g = c; b = 0; }
                else if (h >= 120 && h < 180) { r = 0; g = c; b = x; }
                else if (h >= 180 && h < 240) { r = 0; g = x; b = c; }
                else if (h >= 240 && h < 300) { r = x; g = 0; b = c; }
                else { r = c; g = 0; b = x; }

                r = Math.round((r + m) * 255);
                g = Math.round((g + m) * 255);
                b = Math.round((b + m) * 255);

                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }

            hexToHue(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const diff = max - min;

                let h = 0;
                if (diff !== 0) {
                    if (max === r) h = ((g - b) / diff) % 6;
                    else if (max === g) h = (b - r) / diff + 2;
                    else h = (r - g) / diff + 4;
                }
                h = Math.round(h * 60);
                if (h < 0) h += 360;

                const s = max === 0 ? 0 : diff / max;

                return [Math.round(h / 360 * 65535), Math.round(s * 254)];
            }

            showMessage(message, type) {
                const toast = document.createElement('div');
                toast.className = `message ${type} show`;
                toast.textContent = message;
                document.body.appendChild(toast);
                
                // Auto-remove after 3 seconds
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300); // Wait for fade-out animation
                }, 3000);
            }

            // Global functions for HTML onclick handlers
            async stopEffect(effectId) {
                try {
                    await fetch(`${this.baseUrl}/api/effects/${effectId}/stop`, { method: 'DELETE' });
                    this.showMessage('Effekt gestoppt', 'success');
                    setTimeout(() => this.updateActiveEffects(), 500);
                } catch (error) {
                    this.showMessage('Fehler beim Stoppen: ' + error.message, 'error');
                }
            }

            async cancelTimer(timerId) {
                try {
                    await fetch(`${this.baseUrl}/api/timer/${timerId}`, { method: 'DELETE' });
                    this.showMessage('Timer abgebrochen', 'success');
                    setTimeout(() => this.updateActiveTimers(), 500);
                } catch (error) {
                    this.showMessage('Fehler beim Abbrechen: ' + error.message, 'error');
                }
            }

            async activateMoodScene(sceneType) {
                try {
                    const response = await fetch(`${this.baseUrl}/api/mood-scenes/${sceneType}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ lights: 'all' })
                    });
                    
                    const data = await response.json();
                    if (data.success) {
                        // Message entfernt - keine störenden Banner mehr
                    } else {
                        this.showMessage('Fehler: ' + data.error, 'error');
                    }
                } catch (error) {
                    this.showMessage('Fehler beim Aktivieren der Szene: ' + error.message, 'error');
                }
            }
        }

        // Global functions
        const hue = new HueControllerPro();

        function switchTab(tabName) {
            hue.switchTab(tabName);
        }

        // Neue erweiterte Funktionen
        function updateSliderValue(sliderId, value) {
            document.getElementById(sliderId + '-value').textContent = value;
        }

        // Globale Variable für aktuelle globale Farbe
        let currentGlobalColor = null;

        function setGlobalColor(colorKey) {
            if (!ALL_COLORS[colorKey]) {
                console.error(`Color '${colorKey}' not found in universal palette`);
                return;
            }
            
            const color = ALL_COLORS[colorKey];
            currentGlobalColor = color;
            
            // Update UI
            const displayElement = document.getElementById('current-global-color');
            if (displayElement) displayElement.textContent = color.name;
            
            // Update button active state
            document.querySelectorAll('.global-color-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const activeBtn = document.querySelector(`.global-color-btn[data-color="${colorKey}"]`);
            if (activeBtn) activeBtn.classList.add('active');
            
            // Apply color to only ON lights
            globalColorChangeOnlyOn(color.hue, color.sat);
        }

        // Enhanced global color change that only affects lights that are ON
        async function globalColorChangeOnlyOn(hue, sat) {
            try {
                // First get all lights to check their status
                const lightsResponse = await fetch(`${hue.baseUrl}/api/lights`);
                const lights = await lightsResponse.json();
                
                // Filter only lights that are currently ON
                const onLights = Object.entries(lights).filter(([id, light]) => {
                    return light.state && light.state.on === true;
                });
                
                if (onLights.length === 0) {
                    hue.showMessage('Keine eingeschalteten Lichter gefunden', 'warning');
                    return;
                }
                
                // Apply color to each ON light individually
                const promises = onLights.map(([lightId, light]) => {
                    return fetch(`${hue.baseUrl}/api/lights/${lightId}/state`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            hue: hue, 
                            sat: sat,
                            transitiontime: 4  // Smooth transition
                        })
                    });
                });
                
                await Promise.all(promises);
                hue.showMessage(`Farbe auf ${onLights.length} eingeschaltete${onLights.length === 1 ? 's' : ''} Licht${onLights.length === 1 ? '' : 'er'} angewendet`, 'success');
                
            } catch (error) {
                hue.showMessage('Fehler beim Setzen der globalen Farbe: ' + error.message, 'error');
            }
        }

        // Enhanced function for hex color support - only affects ON lights
        async function setGlobalColorHex(hexColor) {
            try {
                // First get all lights to check their status
                const lightsResponse = await fetch(`${hue.baseUrl}/api/lights`);
                const lights = await lightsResponse.json();
                
                // Filter only lights that are currently ON
                const onLights = Object.entries(lights).filter(([id, light]) => {
                    return light.state && light.state.on === true;
                });
                
                if (onLights.length === 0) {
                    hue.showMessage('Keine eingeschalteten Lichter gefunden', 'warning');
                    return;
                }
                
                // Convert hex to HSB using existing function
                const [hue_val, sat] = hue.hexToHue(hexColor);
                
                // Apply color to each ON light individually
                const promises = onLights.map(([lightId, light]) => {
                    return fetch(`${hue.baseUrl}/api/lights/${lightId}/state`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            hue: hue_val, 
                            sat: sat,
                            transitiontime: 4  // Smooth transition
                        })
                    });
                });
                
                await Promise.all(promises);
                hue.showMessage(`Farbe auf ${onLights.length} eingeschaltete${onLights.length === 1 ? 's' : ''} Licht${onLights.length === 1 ? '' : 'er'} angewendet`, 'success');
                
            } catch (error) {
                hue.showMessage('Fehler beim Setzen der globalen Farbe: ' + error.message, 'error');
            }
        }

        async function activateQuickScene(sceneType) {
            // Use universal color palette for consistent scene definitions
            const scenes = {
                'relax': 'relax',     // Maps to aktivitaet.relax
                'work': 'coolwhite',  // Maps to basis.coolwhite  
                'party': 'party',     // Maps to aktivitaet.party
                'romantic': 'red',    // Maps to spektrum.red
                'reading': 'reading', // Maps to aktivitaet.reading
                'gaming': 'gaming'    // Maps to aktivitaet.gaming
            };

            const colorKey = scenes[sceneType];
            if (!colorKey || !ALL_COLORS[colorKey]) return;
            
            const scene = ALL_COLORS[colorKey];

            try {
                await fetch(`${hue.baseUrl}/api/global/all-lights`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ on: true, ...scene })
                });
                // Message entfernt - keine störenden Banner mehr
            } catch (error) {
                hue.showMessage('Fehler beim Aktivieren der Szene: ' + error.message, 'error');
            }
        }

        async function startAdvancedEffect(effectType) {
            const effectData = {
                'wave': { duration: 60, speed: 2 },
                'pulse': { duration: 30, speed: 1 },
                'rainbow': { duration: 120, speed: 0.5 },
                'fire': { duration: 300, speed: 3 },
                'sunset': { duration: 1800, speed: 0.1 },
                'lightning': { duration: 45, speed: 5 }
            };

            const data = effectData[effectType];
            if (!data) return;

            try {
                await fetch(`${hue.baseUrl}/api/effects/advanced/${effectType}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: 'all', ...data })
                });
                hue.showMessage(`${effectType} Effekt gestartet`, 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Starten des Effekts: ' + error.message, 'error');
            }
        }

        async function startCustomStrobe() {
            const targetType = document.getElementById('effect-target-type').value;
            const targetId = document.getElementById('effect-target-id').value;
            const duration = document.getElementById('strobe-duration').value;
            const speed = document.getElementById('strobe-speed').value;

            if (targetType !== 'all' && !targetId) {
                hue.showMessage('Bitte Target-ID eingeben', 'error');
                return;
            }

            try {
                await fetch(`${hue.baseUrl}/api/effects/strobe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: targetType, 
                        id: targetId, 
                        duration: parseInt(duration), 
                        interval: parseFloat(speed) 
                    })
                });
                hue.showMessage('Strobo gestartet', 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Starten: ' + error.message, 'error');
            }
        }

        async function startCustomColorloop() {
            const targetType = document.getElementById('effect-target-type').value;
            const targetId = document.getElementById('effect-target-id').value;
            const duration = document.getElementById('colorloop-duration').value;

            if (targetType !== 'all' && !targetId) {
                hue.showMessage('Bitte Target-ID eingeben', 'error');
                return;
            }

            try {
                await fetch(`${hue.baseUrl}/api/effects/colorloop`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        type: targetType, 
                        id: targetId, 
                        duration: parseInt(duration) 
                    })
                });
                hue.showMessage('Farbschleife gestartet', 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Starten: ' + error.message, 'error');
            }
        }

        async function startAdvancedStrobe() {
            const targetType = document.getElementById('effect-target-type').value;
            const targetId = document.getElementById('effect-target-id').value;
            const duration = document.getElementById('strobe-duration').value;
            const frequency = document.getElementById('strobe-frequency').value;
            const briVal = document.getElementById('strobe-brightness').value;
            
            // Verwende die gewählte Normal-Strobo-Farbe
            const hueVal = currentNormalStroboColor.hue;
            const satVal = currentNormalStroboColor.sat;
            const mode = document.getElementById('strobe-mode').value;

            if (targetType !== 'all' && !targetId) {
                hue.showMessage('Bitte Target-ID eingeben', 'error');
                return;
            }

            try {
                if (targetType === 'all') {
                    // Nur eingeschaltete Lampen für Strobo verwenden
                    const lightsResponse = await fetch(`${hue.baseUrl}/api/lights`);
                    const lights = await lightsResponse.json();
                    
                    // Filter nur eingeschaltete Lampen
                    const onLights = Object.entries(lights).filter(([id, light]) => {
                        return light.state && light.state.on === true;
                    });
                    
                    if (onLights.length === 0) {
                        hue.showMessage('Keine eingeschalteten Lichter für Strobo gefunden', 'warning');
                        return;
                    }
                    
                    // Strobo für jede eingeschaltete Lampe einzeln starten
                    const promises = onLights.map(([lightId, light]) => {
                        return fetch(`${hue.baseUrl}/api/effects/strobe/advanced`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                target_type: 'light', 
                                target_id: lightId, 
                                duration: parseInt(duration), 
                                frequency: parseFloat(frequency),
                                hue: parseInt(hueVal),
                                sat: parseInt(satVal),
                                bri: parseInt(briVal),
                                mode: mode
                            })
                        });
                    });
                    
                    await Promise.all(promises);
                    const durationText = duration == 0 ? '∞ UNBEGRENZT' : `${duration}s`;
                    hue.showMessage(`${mode.charAt(0).toUpperCase() + mode.slice(1)}-Strobo gestartet (${frequency}Hz) - ${durationText} - ${currentNormalStroboColor.name} - ${onLights.length} Lichter`, 'success');
                } else {
                    // Einzelnes Licht oder Gruppe - normale API-Nutzung
                    await fetch(`${hue.baseUrl}/api/effects/strobe/advanced`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            target_type: targetType, 
                            target_id: targetId, 
                            duration: parseInt(duration), 
                            frequency: parseFloat(frequency),
                            hue: parseInt(hueVal),
                            sat: parseInt(satVal),
                            bri: parseInt(briVal),
                            mode: mode
                        })
                    });
                    const durationText = duration == 0 ? '∞ UNBEGRENZT' : `${duration}s`;
                    hue.showMessage(`${mode.charAt(0).toUpperCase() + mode.slice(1)}-Strobo gestartet (${frequency}Hz) - ${durationText} - ${currentNormalStroboColor.name}`, 'success');
                }
                
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Starten: ' + error.message, 'error');
            }
        }

        function updateStrobeColorPreview() {
            const hue = document.getElementById('strobe-hue').value;
            const sat = document.getElementById('strobe-sat').value;
            const preview = document.getElementById('strobe-color-preview');
            
            // Convert Hue range (0-65535) to CSS hue (0-360)
            const cssHue = Math.round((hue / 65535) * 360);
            // Convert saturation (0-254) to CSS saturation (0-100%)
            const cssSat = Math.round((sat / 254) * 100);
            
            preview.style.backgroundColor = `hsl(${cssHue}, ${cssSat}%, 50%)`;
        }

        async function stopAllEffects() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/effects`);
                const data = await response.json();
                
                for (const effectId of data.active_effects) {
                    await fetch(`${hue.baseUrl}/api/effects/${effectId}/stop`, { method: 'DELETE' });
                }
                
                hue.showMessage('Alle Effekte gestoppt', 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Stoppen der Effekte: ' + error.message, 'error');
            }
        }

        async function globalControl(action) {
            try {
                let endpoint, data;
                
                if (action === 'all-on') {
                    endpoint = '/api/global/all-lights';
                    data = { on: true };
                } else if (action === 'all-off') {
                    // Stop all effects including strobe
                    await stopAllEffects();
                    // Clear all active strobe states
                    hue.activeStrobes = {};
                    // Update all strobe buttons to off state
                    document.querySelectorAll('.btn.warning').forEach(btn => {
                        if (btn.textContent.includes('Strobo AN')) {
                            btn.textContent = '⚡ Strobo';
                            btn.classList.remove('btn-active');
                            // Remove glow effect from card
                            const card = btn.closest('.card');
                            if (card) {
                                card.classList.remove('strobe-active');
                            }
                        }
                    });
                    // Use emergency-off API for better immediate shutdown
                    endpoint = '/api/global/emergency-off';
                    await fetch(`${hue.baseUrl}${endpoint}`, { method: 'POST' });
                }
                
                if (data) {
                    await fetch(`${hue.baseUrl}${endpoint}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(data)
                    });
                }
                
                // Message entfernt - keine störenden Banner mehr
                setTimeout(() => hue.init(), 1000);
            } catch (error) {
                hue.showMessage('Fehler bei globaler Steuerung: ' + error.message, 'error');
            }
        }

        async function globalColorChange(hexColor) {
            const [hue_val, sat] = hue.hexToHue(hexColor);
            try {
                await fetch(`${hue.baseUrl}/api/global/all-lights`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ hue: hue_val, sat: sat })
                });
                // Message entfernt - keine störenden Banner mehr
            } catch (error) {
                hue.showMessage('Fehler beim Setzen der globalen Farbe: ' + error.message, 'error');
            }
        }

        async function globalBrightnessChange(brightness) {
            try {
                await fetch(`${hue.baseUrl}/api/global/all-lights`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ bri: parseInt(brightness), transitiontime: 4 })
                });
                // Keine störende Nachricht
            } catch (error) {
                hue.showMessage('Fehler beim Setzen der globalen Helligkeit: ' + error.message, 'error');
            }
        }

        // Globale Funktion für Power View Switch
        async function switchPowerView(view) {
            if (typeof hue !== 'undefined') {
                await hue.switchPowerView(view);
            }
        }

        async function startStrobe() {
            const type = document.getElementById('strobe-target-type').value;
            const id = document.getElementById('strobe-target-id').value;
            const duration = document.getElementById('strobe-duration').value;
            const interval = document.getElementById('strobe-interval').value;
            
            if (!id) {
                hue.showMessage('Bitte ID eingeben', 'error');
                return;
            }
            
            try {
                await fetch(`${hue.baseUrl}/api/effects/strobe`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type, id, duration: parseInt(duration), interval: parseFloat(interval) })
                });
                hue.showMessage('Strobo gestartet', 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Starten des Strobos: ' + error.message, 'error');
            }
        }

        async function startColorloop() {
            const type = document.getElementById('colorloop-target-type').value;
            const id = document.getElementById('colorloop-target-id').value;
            const duration = document.getElementById('colorloop-duration').value;
            
            if (!id) {
                hue.showMessage('Bitte ID eingeben', 'error');
                return;
            }
            
            try {
                await fetch(`${hue.baseUrl}/api/effects/colorloop`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type, id, duration: parseInt(duration) })
                });
                hue.showMessage('Farbschleife gestartet', 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Starten der Farbschleife: ' + error.message, 'error');
            }
        }

        async function createTimer() {
            const type = document.getElementById('timer-target-type').value;
            const id = document.getElementById('timer-target-id').value;
            const delay = document.getElementById('timer-delay').value;
            const actionType = document.getElementById('timer-action').value;
            
            if (!id) {
                hue.showMessage('Bitte ID eingeben', 'error');
                return;
            }
            
            const action = actionType === 'on' ? { on: true } : { on: false };
            
            try {
                await fetch(`${hue.baseUrl}/api/timer`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type, id, delay: parseInt(delay), action })
                });
                hue.showMessage('Timer erstellt', 'success');
                setTimeout(() => hue.updateActiveTimers(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Erstellen des Timers: ' + error.message, 'error');
            }
        }

        // Audio-Sync Funktionen
        async function startAudioSync() {
            const deviceIndex = document.getElementById('audio-device-select').value;
            const syncMode = document.getElementById('sync-mode-select').value;
            const sensitivity = parseFloat(document.getElementById('audio-sensitivity').value);
            
            if (!deviceIndex) {
                hue.showMessage('Bitte Audio-Gerät auswählen', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${hue.baseUrl}/api/audio/start-sync`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        device_index: parseInt(deviceIndex),
                        mode: syncMode,
                        sensitivity: sensitivity
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    document.getElementById('start-audio-sync').style.display = 'none';
                    document.getElementById('stop-audio-sync').style.display = 'block';
                    document.getElementById('audio-sync-container').classList.add('audio-sync-active');
                    showAudioStatus(data.message, 'success');
                } else {
                    showAudioStatus(data.error || 'Fehler beim Starten', 'error');
                }
            } catch (error) {
                showAudioStatus('Verbindungsfehler: ' + error.message, 'error');
            }
        }

        async function stopAudioSync() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/audio/stop-sync`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                if (data.success) {
                    document.getElementById('start-audio-sync').style.display = 'block';
                    document.getElementById('stop-audio-sync').style.display = 'none';
                    document.getElementById('audio-sync-container').classList.remove('audio-sync-active');
                    showAudioStatus(data.message, 'success');
                } else {
                    showAudioStatus('Fehler beim Stoppen', 'error');
                }
            } catch (error) {
                showAudioStatus('Verbindungsfehler: ' + error.message, 'error');
            }
        }

        function showAudioStatus(message, type) {
            const statusDiv = document.getElementById('audio-status');
            statusDiv.className = `message ${type}`;
            statusDiv.textContent = message;
            statusDiv.style.display = 'block';
            
            setTimeout(() => {
                statusDiv.style.display = 'none';
            }, 5000);
        }

        // === SMART ERROR HANDLING ===
        
        async function checkSystemHealth() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/system/health`);
                const data = await response.json();
                
                if (data.success) {
                    displayHealthStatus(data.health);
                }
            } catch (error) {
                console.error('Health check failed:', error);
            }
        }
        
        function displayHealthStatus(health) {
            let healthHtml = `
                <div class="health-status ${health.status}">
                    <h4>🔧 System-Status: ${health.status.toUpperCase()}</h4>
                    <div class="health-checks">
            `;
            
            for (const [check, status] of Object.entries(health.checks)) {
                const icon = status === 'ok' ? '✅' : '❌';
                healthHtml += `<div class="health-check">${icon} ${check}: ${status}</div>`;
            }
            
            healthHtml += '</div>';
            
            if (health.recommendations && health.recommendations.length > 0) {
                healthHtml += '<div class="recommendations"><h5>🔍 Empfehlungen:</h5><ul>';
                health.recommendations.forEach(rec => {
                    healthHtml += `<li>${rec}</li>`;
                });
                healthHtml += '</ul></div>';
            }
            
            healthHtml += '</div>';
            
            // Show in status section or create modal
            showSystemModal('System-Gesundheit', healthHtml);
        }
        
        async function diagnoseIssue(issueType) {
            try {
                const response = await fetch(`${hue.baseUrl}/api/system/diagnose`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ type: issueType })
                });
                
                const data = await response.json();
                if (data.success) {
                    displayDiagnosis(data.diagnosis);
                }
            } catch (error) {
                hue.showMessage('Diagnose fehlgeschlagen: ' + error.message, 'error');
            }
        }
        
        function displayDiagnosis(diagnosis) {
            let diagnosisHtml = `
                <div class="diagnosis-result">
                    <h4>🔍 Diagnose: ${diagnosis.issue_type}</h4>
                    <div class="diagnosis-tests">
            `;
            
            for (const [test, result] of Object.entries(diagnosis.tests)) {
                diagnosisHtml += `<div class="test-result"><strong>${test}:</strong> ${result}</div>`;
            }
            
            diagnosisHtml += '</div>';
            
            if (diagnosis.solutions && diagnosis.solutions.length > 0) {
                diagnosisHtml += '<div class="solutions"><h5>💡 Lösungsvorschläge:</h5><ul>';
                diagnosis.solutions.forEach(solution => {
                    diagnosisHtml += `<li>${solution}</li>`;
                });
                diagnosisHtml += '</ul></div>';
            }
            
            diagnosisHtml += '</div>';
            showSystemModal('Diagnose-Ergebnis', diagnosisHtml);
        }
        
        async function performRecovery(action) {
            try {
                const response = await fetch(`${hue.baseUrl}/api/system/recovery`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: action })
                });
                
                const data = await response.json();
                if (data.success) {
                    hue.showMessage(data.recovery.message, 'success');
                } else {
                    hue.showMessage('Recovery fehlgeschlagen: ' + data.recovery.message, 'error');
                }
            } catch (error) {
                hue.showMessage('Recovery-Aktion fehlgeschlagen: ' + error.message, 'error');
            }
        }
        
        function showSystemModal(title, content) {
            // Simple modal implementation
            const modal = document.createElement('div');
            modal.className = 'system-modal';
            modal.innerHTML = `
                <div class="modal-backdrop" onclick="this.parentElement.remove()"></div>
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>${title}</h3>
                        <button onclick="this.closest('.system-modal').remove()">×</button>
                    </div>
                    <div class="modal-body">${content}</div>
                    <div class="modal-footer">
                        <button onclick="this.closest('.system-modal').remove()">Schließen</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // Enhanced error handling for API calls
        async function smartFetch(url, options = {}) {
            try {
                const response = await fetch(url, options);
                const data = await response.json();
                
                if (!response.ok || !data.success) {
                    if (data.error) {
                        // Smart error with solutions
                        showSmartError(data.error);
                    } else {
                        throw new Error(data.message || 'Unbekannter Fehler');
                    }
                    return null;
                }
                
                return data;
            } catch (error) {
                hue.showMessage('Netzwerkfehler: ' + error.message, 'error');
                return null;
            }
        }
        
        function showSmartError(errorInfo) {
            const errorHtml = `
                <div class="smart-error">
                    <h4>❌ ${errorInfo.title}</h4>
                    <p class="error-message">${errorInfo.message}</p>
                    <div class="error-solutions">
                        <h5>💡 Lösungsvorschläge:</h5>
                        <ul>
                            ${errorInfo.solutions.map(solution => `<li>${solution}</li>`).join('')}
                        </ul>
                    </div>
                    <div class="error-actions">
                        <button onclick="diagnoseIssue('${errorInfo.category}')" class="btn secondary">
                            🔍 Diagnose starten
                        </button>
                        ${getRecoveryButton(errorInfo.category)}
                    </div>
                    <details class="technical-details">
                        <summary>Technische Details</summary>
                        <p>${errorInfo.technical_details}</p>
                        <p>Error ID: ${errorInfo.error_id}</p>
                    </details>
                </div>
            `;
            showSystemModal('Intelligente Fehlerbehandlung', errorHtml);
        }
        
        function getRecoveryButton(category) {
            const recoveryActions = {
                'effect_system': 'restart_effects',
                'database_connection': 'reset_database_pool',
                'hue_bridge_connection': 'test_bridge',
                'audio_system': 'stop_audio'
            };
            
            const action = recoveryActions[category];
            if (action) {
                return `<button onclick="performRecovery('${action}')" class="btn danger">
                    🔧 Auto-Recovery
                </button>`;
            }
            return '';
        }
        
        // Periodische System-Health-Checks deaktiviert
        // setInterval(checkSystemHealth, 300000); // Alle 5 Minuten

        // Debug-System Variablen
        let debugAutoScroll = true;
        let debugUpdateInterval = null;

        // Debug-Funktionen
        async function updateDebugData() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/debug/logs`);
                const data = await response.json();
                
                // Logs aktualisieren
                const debugLog = document.getElementById('debug-log');
                debugLog.innerHTML = data.logs.map(log => `
                    <div class="debug-entry ${log.type}">
                        <span class="debug-time">${log.timestamp}</span>
                        <span class="debug-type ${log.type}">${log.type.toUpperCase()}</span>
                        <span class="debug-message">${log.message}</span>
                    </div>
                `).join('');
                
                // Auto-scroll wenn aktiviert
                if (debugAutoScroll) {
                    debugLog.scrollTop = debugLog.scrollHeight;
                }
                
                // Stats aktualisieren
                document.getElementById('debug-bridge-status').textContent = 
                    data.stats.bridge_status === 'connected' ? '✅' : 
                    data.stats.bridge_status === 'error' ? '❌' : '🔍';
                document.getElementById('debug-last-request').textContent = 
                    data.stats.last_request || '--';
                document.getElementById('debug-request-count').textContent = 
                    data.stats.total_requests;
                document.getElementById('debug-error-count').textContent = 
                    data.stats.error_count;
                    
            } catch (error) {
                console.error('Debug update error:', error);
            }
        }

        function clearDebugLog() {
            fetch(`${hue.baseUrl}/api/debug/clear`, { method: 'POST' });
            setTimeout(updateDebugData, 100);
        }

        function toggleDebugAutoScroll() {
            debugAutoScroll = !debugAutoScroll;
            document.getElementById('autoscroll-status').textContent = debugAutoScroll ? 'AN' : 'AUS';
        }

        function updateMaxLogEntries() {
            // Placeholder für zukünftige Implementierung
        }

        async function testHueConnection() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/debug/test/connection`, { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    hue.showMessage(`Bridge-Test erfolgreich: ${data.bridge_name}`, 'success');
                } else {
                    hue.showMessage(`Bridge-Test fehlgeschlagen: ${data.error}`, 'error');
                }
                setTimeout(updateDebugData, 500);
            } catch (error) {
                hue.showMessage('Fehler beim Bridge-Test', 'error');
            }
        }

        async function testLightCommand() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/debug/test/light`, { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    hue.showMessage(`Licht ${data.light_id} Test-Blink gesendet`, 'success');
                } else {
                    hue.showMessage(`Licht-Test fehlgeschlagen: ${data.error}`, 'error');
                }
                setTimeout(updateDebugData, 500);
            } catch (error) {
                hue.showMessage('Fehler beim Licht-Test', 'error');
            }
        }

        async function testGroupCommand() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/debug/test/group`, { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    hue.showMessage('Gruppen-Test erfolgreich', 'success');
                } else {
                    hue.showMessage(`Gruppen-Test fehlgeschlagen: ${data.error}`, 'error');
                }
                setTimeout(updateDebugData, 500);
            } catch (error) {
                hue.showMessage('Fehler beim Gruppen-Test', 'error');
            }
        }

        async function sendTestStrobe() {
            try {
                const response = await fetch(`${hue.baseUrl}/api/debug/test/strobe`, { method: 'POST' });
                const data = await response.json();
                if (data.success) {
                    hue.showMessage('Test-Strobo gestartet (3s)', 'success');
                } else {
                    hue.showMessage(`Test-Strobo fehlgeschlagen: ${data.error}`, 'error');
                }
                setTimeout(updateDebugData, 500);
            } catch (error) {
                hue.showMessage('Fehler beim Test-Strobo', 'error');
            }
        }

        // Ultra-Strobo Funktionen
        async function startUltraStrobo(mode, frequency) {
            // Sicherheitswarnung bei hohen Frequenzen
            if (frequency > 15) {
                const confirmed = confirm(`⚠️ WARNUNG: ${frequency}Hz kann bei photosensitiven Personen Anfälle auslösen!\n\nWirklich fortfahren?`);
                if (!confirmed) return;
            }

            const targetType = document.getElementById('effect-target-type').value;
            const targetId = document.getElementById('effect-target-id').value;
            const duration = 0; // Unbegrenzt für Presets

            if (targetType !== 'all' && !targetId) {
                hue.showMessage('Bitte Target-ID eingeben', 'error');
                return;
            }

            try {
                await fetch(`${hue.baseUrl}/api/effects/strobe/ultra`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        target_type: targetType, 
                        target_id: targetId, 
                        duration: duration,
                        frequency: frequency,
                        mode: mode,
                        hue: currentStroboColor.hue,
                        sat: currentStroboColor.sat,
                        bri: currentStroboColor.bri,
                        intensity: 1.0
                    })
                });
                hue.showMessage(`🔥 ${mode.toUpperCase()}-STROBO gestartet (${frequency}Hz) - ∞ UNBEGRENZT`, 'success');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Ultra-Strobo: ' + error.message, 'error');
            }
        }

        // === ZENTRALE FARBDEFINITION FÜR ALLE BEREICHE ===
        const UNIVERSAL_COLOR_PALETTES = {
            basis: {
                warmwhite: { name: 'Warmweiß', hue: 8000, sat: 80, bri: 200, color: '#FFF2CC' },
                coolwhite: { name: 'Kaltweiß', hue: 0, sat: 0, bri: 254, color: '#FFFFFF' },
                neutralwhite: { name: 'Neutralweiß', hue: 6500, sat: 40, bri: 180, color: '#F5F5F5' },
                daylight: { name: 'Tageslicht', hue: 4000, sat: 60, bri: 220, color: '#FFFACD' }
            },
            stimmung: {
                sunset: { name: 'Sonnenuntergang', hue: 5000, sat: 200, bri: 120, color: '#FF7F50' },
                evening: { name: 'Abendhimmel', hue: 45000, sat: 180, bri: 100, color: '#9370DB' },
                candle: { name: 'Kerzenschein', hue: 12000, sat: 220, bri: 80, color: '#FFA500' },
                moonlight: { name: 'Mondlicht', hue: 42000, sat: 40, bri: 60, color: '#B0C4DE' }
            },
            aktivitaet: {
                reading: { name: 'Lesen', hue: 4000, sat: 60, bri: 220, color: '#FFFAF0' },
                gaming: { name: 'Gaming', hue: 46000, sat: 254, bri: 180, color: '#0066FF' },
                relax: { name: 'Entspannung', hue: 14000, sat: 140, bri: 100, color: '#FFEBCD' },
                party: { name: 'Party', hue: 25000, sat: 254, bri: 254, color: '#00FF00' }
            },
            spektrum: {
                red: { name: 'Feuerrot', hue: 65000, sat: 254, bri: 200, color: '#FF0000' },
                yellow: { name: 'Sonnengelb', hue: 15000, sat: 254, bri: 220, color: '#FFFF00' },
                green: { name: 'Naturgrün', hue: 25000, sat: 200, bri: 180, color: '#00FF00' },
                blue: { name: 'Himmelblau', hue: 46000, sat: 200, bri: 200, color: '#0066FF' }
            }
        };

        // Flatten all colors for easy access
        const ALL_COLORS = {};
        Object.keys(UNIVERSAL_COLOR_PALETTES).forEach(category => {
            Object.keys(UNIVERSAL_COLOR_PALETTES[category]).forEach(colorKey => {
                ALL_COLORS[colorKey] = UNIVERSAL_COLOR_PALETTES[category][colorKey];
            });
        });

        // Legacy color mapping for backward compatibility
        const LEGACY_COLOR_MAPPING = {
            'white': 'coolwhite',
            'red': 'red', 
            'blue': 'blue',
            'green': 'green',
            'purple': 'evening',
            'orange': 'candle'
        };

        // Helper function to get color name from hex value
        function getColorNameFromHex(hexColor) {
            const colorMap = {
                '#ff0000': 'Rot',
                '#00ff00': 'Grün',
                '#0066ff': 'Blau',
                '#ffff00': 'Gelb',
                '#ff00ff': 'Magenta',
                '#00ffff': 'Cyan',
                '#ff8000': 'Orange',
                '#8000ff': 'Violett',
                '#fff2cc': 'Warmweiß',
                '#ffffff': 'Kaltweiß',
                '#f5f5f5': 'Neutralweiß',
                '#fffacd': 'Tageslicht'
            };
            return colorMap[hexColor.toLowerCase()] || 'Benutzerdefiniert';
        }

        // Globale Variable für Strobo-Farbe
        let currentStroboColor = {
            name: 'Kaltweiß',
            hue: 0,
            sat: 0,
            bri: 254
        };

        function updateUltraDurationValue(value) {
            const display = document.getElementById('ultra-duration-value');
            if (value == 0) {
                display.textContent = '∞ Unbegrenzt';
            } else {
                display.textContent = value + 's';
            }
        }

        function updateColorloopDurationValue(value) {
            const display = document.getElementById('colorloop-duration-value');
            if (value == 0) {
                display.textContent = '∞ Unbegrenzt';
            } else {
                display.textContent = value + 's';
            }
        }

        // === EINHEITLICHE FARBAUSWAHL-FUNKTIONEN ===
        function setUniversalColor(colorKey, targetType = 'strobo') {
            // Map legacy color names to new system
            const mappedColorKey = LEGACY_COLOR_MAPPING[colorKey] || colorKey;
            
            if (!ALL_COLORS[mappedColorKey]) {
                console.error(`Color '${colorKey}' not found in universal palette`);
                return;
            }
            
            const color = ALL_COLORS[mappedColorKey];
            
            // Update appropriate global variable based on target type
            if (targetType === 'strobo') {
                currentStroboColor = { ...color };
                
                // Update UI elements
                const displayElement = document.getElementById('current-strobo-color');
                if (displayElement) displayElement.textContent = color.name;
                
                // Update hidden inputs
                const hueInput = document.getElementById('strobe-hue');
                const satInput = document.getElementById('strobe-sat');
                const briInput = document.getElementById('strobe-brightness');
                
                if (hueInput) hueInput.value = color.hue;
                if (satInput) satInput.value = color.sat;
                if (briInput) briInput.value = color.bri;
                
                // Update button active state
                document.querySelectorAll('.color-preset-btn:not(.normal-strobe-color)').forEach(btn => {
                    btn.classList.remove('active');
                });
                const activeBtn = document.querySelector(`[data-color="${colorKey}"]`);
                if (activeBtn) activeBtn.classList.add('active');
                
            } else if (targetType === 'normal-strobo') {
                currentNormalStroboColor = { ...color };
                
                // Update UI elements
                const displayElement = document.getElementById('current-normal-strobo-color');
                if (displayElement) displayElement.textContent = color.name;
                
                // Update hidden inputs
                const hueInput = document.getElementById('strobe-hue');
                const satInput = document.getElementById('strobe-sat');
                
                if (hueInput) hueInput.value = color.hue;
                if (satInput) satInput.value = color.sat;
                
                // Update button active state
                document.querySelectorAll('.normal-strobe-color').forEach(btn => {
                    btn.classList.remove('active');
                });
                const activeBtn = document.querySelector(`.normal-strobe-color[data-color="${colorKey}"]`);
                if (activeBtn) activeBtn.classList.add('active');
            }
        }

        // Legacy wrapper functions for backward compatibility
        function setStroboColor(colorName) {
            setUniversalColor(colorName, 'strobo');
        }

        // Hex color support for Ultra Strobo
        function setStroboColorHex(hexColor) {
            const [hue_val, sat] = hue.hexToHue(hexColor);
            
            // Update global variable
            currentStroboColor = {
                name: getColorNameFromHex(hexColor),
                hue: hue_val,
                sat: sat,
                bri: 254
            };
            
            // Update UI elements
            const displayElement = document.getElementById('current-strobo-color');
            if (displayElement) displayElement.textContent = currentStroboColor.name;
            
            // Update hidden inputs
            const hueInput = document.getElementById('strobe-hue');
            const satInput = document.getElementById('strobe-sat');
            const briInput = document.getElementById('strobe-brightness');
            
            if (hueInput) hueInput.value = hue_val;
            if (satInput) satInput.value = sat;
            if (briInput) briInput.value = 254;
        }

        // Globale Variable für Normal-Strobo-Farbe
        let currentNormalStroboColor = {
            name: 'Kaltweiß',
            hue: 0,
            sat: 0,
            bri: 254
        };

        function updateNormalStrobeDurationValue(value) {
            const display = document.getElementById('strobe-duration-value');
            if (value == 0) {
                display.textContent = '∞ Unbegrenzt';
            } else {
                display.textContent = value + 's';
            }
        }

        function setNormalStroboColor(colorName) {
            setUniversalColor(colorName, 'normal-strobo');
        }

        // Hex color support for Normal Strobo
        function setNormalStroboColorHex(hexColor) {
            const [hue_val, sat] = hue.hexToHue(hexColor);
            
            // Update global variable
            currentNormalStroboColor = {
                name: getColorNameFromHex(hexColor),
                hue: hue_val,
                sat: sat,
                bri: 254
            };
            
            // Update UI elements
            const displayElement = document.getElementById('current-normal-strobo-color');
            if (displayElement) displayElement.textContent = currentNormalStroboColor.name;
            
            // Update hidden inputs
            const hueInput = document.getElementById('strobe-hue');
            const satInput = document.getElementById('strobe-sat');
            
            if (hueInput) hueInput.value = hue_val;
            if (satInput) satInput.value = sat;
        }

        // === KLAPPBARE CARDS FUNKTIONALITÄT ===
        
        // Toggle card expanded/collapsed state
        function toggleCard(cardId) {
            const content = document.getElementById(cardId + '-content');
            const icon = document.getElementById(cardId + '-icon');
            
            if (content.classList.contains('collapsed')) {
                // Expand
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                icon.classList.remove('collapsed');
                
                // Set max-height to auto for proper content display
                content.style.maxHeight = 'none';
                
                // Save expanded state to localStorage
                localStorage.setItem('card-' + cardId, 'expanded');
            } else {
                // Collapse
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                icon.classList.add('collapsed');
                content.style.maxHeight = '0';
                
                // Save collapsed state to localStorage
                localStorage.setItem('card-' + cardId, 'collapsed');
            }
        }
        
        // Initialize card states from localStorage
        function initializeCardStates() {
            const cards = ['quickaccess', 'globalcontrols'];
            
            cards.forEach(cardId => {
                const content = document.getElementById(cardId + '-content');
                const icon = document.getElementById(cardId + '-icon');
                const savedState = localStorage.getItem('card-' + cardId);
                
                if (savedState === 'collapsed') {
                    content.classList.add('collapsed');
                    icon.classList.add('collapsed');
                    content.style.maxHeight = '0';
                } else {
                    // Default to expanded
                    content.classList.add('expanded');
                    content.style.maxHeight = 'none';
                }
            });
        }
        
        // Initialize default color on page load
        document.addEventListener('DOMContentLoaded', function() {
            setNormalStroboColorHex('#ff0000');  // Red as default
            initializeCardStates();  // Initialize collapsible cards
        });

        async function startCustomUltraStrobo() {
            const targetType = document.getElementById('effect-target-type').value;
            const targetId = document.getElementById('effect-target-id').value;
            const frequency = document.getElementById('ultra-frequency').value;
            const duration = document.getElementById('ultra-duration').value;
            
            // Verwende die gewählte Strobo-Farbe
            const hueVal = currentStroboColor.hue;
            const satVal = currentStroboColor.sat;
            const briVal = currentStroboColor.bri;

            // Extra Sicherheitswarnung
            if (frequency > 20) {
                const confirmed = confirm(`🚨 EXTREME WARNUNG: ${frequency}Hz ist SEHR GEFÄHRLICH!\n\nKann schwere epileptische Anfälle auslösen!\n\nNur für Tests unter kontrollierten Bedingungen!\n\nFortfahren?`);
                if (!confirmed) return;
            } else if (frequency > 15) {
                const confirmed = confirm(`⚠️ WARNUNG: ${frequency}Hz kann bei photosensitiven Personen Anfälle auslösen!\n\nWirklich fortfahren?`);
                if (!confirmed) return;
            }

            if (targetType !== 'all' && !targetId) {
                hue.showMessage('Bitte Target-ID eingeben', 'error');
                return;
            }

            try {
                await fetch(`${hue.baseUrl}/api/effects/strobe/ultra`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        target_type: targetType, 
                        target_id: targetId, 
                        duration: parseInt(duration),
                        frequency: parseFloat(frequency),
                        mode: 'ultra',
                        hue: parseInt(hueVal),
                        sat: parseInt(satVal),
                        bri: parseInt(briVal),
                        intensity: 1.0
                    })
                });
                const durationText = duration == 0 ? '∞ UNBEGRENZT' : `${duration}s`;
                hue.showMessage(`🔥 CUSTOM ULTRA-STROBO gestartet (${frequency}Hz) - ${durationText} - ${currentStroboColor.name}`, 'warning');
                setTimeout(() => hue.updateActiveEffects(), 1000);
            } catch (error) {
                hue.showMessage('Fehler beim Custom Ultra-Strobo: ' + error.message, 'error');
            }
        }


        function checkEpilepsyWarning(frequency) {
            const freq = parseFloat(frequency);
            const warningBox = document.querySelector('.warning-box');
            
            if (freq > 20) {
                warningBox.style.background = 'rgba(211, 47, 47, 0.3)';
                warningBox.style.borderColor = '#d32f2f';
                warningBox.innerHTML = '🚨 <strong>EXTREME GEFAHR!</strong><br>Frequenz über 20Hz kann schwere epileptische Anfälle auslösen!<br>NUR für kontrollierte Tests!';
            } else if (freq > 15) {
                warningBox.style.background = 'rgba(255, 68, 68, 0.3)';
                warningBox.style.borderColor = '#ff4444';
                warningBox.innerHTML = '⚠️ <strong>HOHE GEFAHR!</strong><br>Frequenz über 15Hz kann epileptische Anfälle auslösen!<br>Extreme Vorsicht geboten!';
            } else {
                warningBox.style.background = 'rgba(255, 152, 0, 0.2)';
                warningBox.style.borderColor = '#ff9800';
                warningBox.innerHTML = '⚠️ <strong>EPILEPSIE-WARNUNG!</strong><br>Ultra-Strobo kann bei photosensitiven Personen Anfälle auslösen!<br>Frequenzen über 15Hz sind besonders gefährlich.';
            }
        }

        // Guide Navigation Functions
        function showGuideSection(sectionName) {
            // Hide all guide sections
            document.querySelectorAll('.guide-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Remove active class from all nav buttons
            document.querySelectorAll('.guide-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected section
            const targetSection = document.getElementById(`guide-${sectionName}`);
            if (targetSection) {
                targetSection.classList.add('active');
            }
            
            // Activate clicked nav button
            event.target.classList.add('active');
            
            // Scroll to top of guide
            document.getElementById('guide-tab').scrollTop = 0;
        }

        // Global functions for individual lamp chart
        function updateIndividualLampChart() {
            if (hue) {
                hue.updateIndividualLampChart();
            }
        }
        
        // Debug-spezifische switchTab Erweiterung
        const originalSwitchTab = window.switchTab;
        window.switchTab = function(tabName) {
            // Ursprüngliche Funktion aufrufen
            if (originalSwitchTab) {
                originalSwitchTab(tabName);
            } else {
                // Fallback wenn ursprüngliche Funktion nicht existiert
                document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
                const clickedTab = document.querySelector(`button[onclick*="${tabName}"]`);
                if (clickedTab) clickedTab.classList.add('active');
                
                document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active'));
                const activeNavItem = document.querySelector(`[data-tab="${tabName}"]`);
                if (activeNavItem) {
                    activeNavItem.classList.add('active');
                }
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                const tabContent = document.getElementById(tabName + '-tab');
                if (tabContent) tabContent.classList.add('active');
                
                hue.activeTab = tabName;
            }

            // Tab-spezifische Aktionen
            if (tabName === 'debug') {
                updateDebugData();
                // debugUpdateInterval = setInterval(updateDebugData, 60000); // Auto-Update deaktiviert
            } else {
                if (debugUpdateInterval) {
                    clearInterval(debugUpdateInterval);
                    debugUpdateInterval = null;
                }
            }
            
            // Power-Tab spezifische Aktionen
            if (tabName === 'power') {
                // Lade Lampen-Auswahl beim ersten Mal
                if (!hue.lampSelectionLoaded) {
                    hue.loadLampSelection();
                    hue.lampSelectionLoaded = true;
                }
            }
            
            // Button-Tab spezifische Aktionen
            if (tabName === 'buttons') {
                console.log('Loading buttons tab...');
                if (!hue.buttonsLoaded) {
                    console.log('First time loading buttons tab');
                    loadButtonConfigurations();
                    loadButtonStatus();
                    loadButtonLogs();
                    loadGroupsForButtons();
                    hue.buttonsLoaded = true;
                } else {
                    console.log('Buttons tab already loaded');
                }
            }
        };

        // ═══════════════════ BUTTON CONFIGURATION FUNCTIONS ═══════════════════

        let buttonConfigurations = [];
        let availableGroups = [];

        // Simple notification function if not exists
        function showNotification(message, type = 'info') {
            console.log(`${type.toUpperCase()}: ${message}`);
            // You could add a proper notification system here
            alert(message);
        }

        async function loadButtonConfigurations() {
            try {
                const response = await fetch('/api/buttons/configurations');
                const data = await response.json();
                
                if (data.success) {
                    buttonConfigurations = data.configurations;
                    renderButtonConfigurations();
                } else {
                    console.error('Failed to load button configurations:', data.error);
                    showNotification('❌ Fehler beim Laden der Button-Konfigurationen', 'error');
                }
            } catch (error) {
                console.error('Error loading button configurations:', error);
                showNotification('❌ Verbindungsfehler', 'error');
            }
        }

        async function loadButtonStatus() {
            try {
                const response = await fetch('/api/buttons/status');
                const data = await response.json();
                
                if (data.success) {
                    updateGpioStatus(data.gpio_monitoring);
                }
            } catch (error) {
                console.error('Error loading button status:', error);
            }
        }

        async function loadGroupsForButtons() {
            try {
                const response = await fetch('/api/groups');
                const data = await response.json();
                
                // Handle direct Hue API response (data is the groups object)
                if (data && typeof data === 'object' && !data.error) {
                    availableGroups = Object.entries(data).map(([id, group]) => ({
                        id,
                        name: group.name
                    }));
                    
                    // Add "All Lights" option
                    availableGroups.unshift({ id: '0', name: 'Alle Lichter' });
                    
                    populateGroupSelect();
                    console.log('Loaded groups:', availableGroups);
                } else {
                    console.error('Groups API returned error:', data);
                }
            } catch (error) {
                console.error('Error loading groups for buttons:', error);
            }
        }

        function populateGroupSelect() {
            const select = document.getElementById('button-group');
            if (!select) {
                console.error('button-group select element not found');
                return;
            }
            
            select.innerHTML = '<option value="">-- Gruppe wählen --</option>';
            
            if (availableGroups.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '❌ Keine Gruppen verfügbar';
                option.disabled = true;
                select.appendChild(option);
                return;
            }
            
            availableGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                select.appendChild(option);
            });
            
            console.log(`Populated ${availableGroups.length} groups in select`);
        }

        function updateGpioStatus(status) {
            const statusElement = document.getElementById('gpio-status');
            const statusText = document.getElementById('gpio-status-text');
            const statusDot = statusElement.querySelector('.status-dot');
            
            if (status.running) {
                statusDot.classList.add('online');
                statusText.textContent = `GPIO Monitoring aktiv - ${status.active_buttons} Button(s) konfiguriert`;
            } else {
                statusDot.classList.remove('online');
                statusText.textContent = status.message || 'GPIO Monitoring inaktiv';
            }
        }

        function renderButtonConfigurations() {
            const container = document.getElementById('button-configurations');
            
            if (buttonConfigurations.length === 0) {
                container.innerHTML = '<div class="loading-spinner">Keine Button-Konfigurationen vorhanden</div>';
                return;
            }
            
            container.innerHTML = buttonConfigurations.map(config => `
                <div class="button-config-item">
                    <div class="button-config-info">
                        <div class="button-config-title">
                            🔘 ${config.button_name || `GPIO Pin ${config.gpio_pin}`}
                        </div>
                        <div class="button-config-details">
                            Pin: ${config.gpio_pin} → ${config.group_name} (${config.action_type})
                            ${config.enabled ? '✅ Aktiv' : '❌ Deaktiviert'}
                        </div>
                    </div>
                    <div class="button-config-actions">
                        <button class="small-btn" onclick="testButton(${config.gpio_pin})" 
                                title="Button testen">
                            🧪 Test
                        </button>
                        <button class="small-btn" onclick="editButtonConfiguration(${config.id})" 
                                style="background: var(--accent-green);" title="Bearbeiten">
                            ✏️ Edit
                        </button>
                        <button class="small-btn" onclick="deleteButtonConfiguration(${config.id})" 
                                style="background: var(--accent-red);" title="Löschen">
                            🗑️ Del
                        </button>
                    </div>
                </div>
            `).join('');
        }

        async function addButtonConfiguration() {
            const gpioPin = document.getElementById('gpio-pin').value;
            const groupId = document.getElementById('button-group').value;
            const actionType = document.getElementById('button-action').value;
            const buttonName = document.getElementById('button-name').value;
            
            if (!gpioPin || !groupId) {
                showNotification('❌ Bitte GPIO Pin und Gruppe auswählen', 'error');
                return;
            }
            
            try {
                const response = await fetch('/api/buttons/configurations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        gpio_pin: parseInt(gpioPin),
                        group_id: groupId,
                        action_type: actionType,
                        button_name: buttonName || `Button GPIO ${gpioPin}`
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showNotification('✅ Button-Konfiguration hinzugefügt', 'success');
                    
                    // Clear form
                    document.getElementById('gpio-pin').value = '';
                    document.getElementById('button-group').value = '';
                    document.getElementById('button-action').value = 'toggle';
                    document.getElementById('button-name').value = '';
                    
                    // Reload configurations
                    loadButtonConfigurations();
                    loadButtonStatus();
                } else {
                    showNotification(`❌ ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Error adding button configuration:', error);
                showNotification('❌ Verbindungsfehler', 'error');
            }
        }

        async function testButton(gpioPin) {
            try {
                const response = await fetch(`/api/buttons/test/${gpioPin}`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showNotification(`✅ Test erfolgreich: ${data.message}`, 'success');
                    loadButtonLogs(); // Refresh logs
                } else {
                    showNotification(`❌ Test fehlgeschlagen: ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Error testing button:', error);
                showNotification('❌ Test-Verbindungsfehler', 'error');
            }
        }

        async function deleteButtonConfiguration(configId) {
            if (!confirm('Sind Sie sicher, dass Sie diese Button-Konfiguration löschen möchten?')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/buttons/configurations/${configId}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showNotification('✅ Button-Konfiguration gelöscht', 'success');
                    loadButtonConfigurations();
                    loadButtonStatus();
                } else {
                    showNotification(`❌ ${data.error}`, 'error');
                }
            } catch (error) {
                console.error('Error deleting button configuration:', error);
                showNotification('❌ Verbindungsfehler', 'error');
            }
        }

        async function loadButtonLogs() {
            try {
                const response = await fetch('/api/buttons/logs?limit=20');
                const data = await response.json();
                
                if (data.success) {
                    renderButtonLogs(data.logs);
                } else {
                    console.error('Failed to load button logs:', data.error);
                }
            } catch (error) {
                console.error('Error loading button logs:', error);
            }
        }

        function renderButtonLogs(logs) {
            const container = document.getElementById('button-logs');
            
            if (logs.length === 0) {
                container.innerHTML = '<div class="loading-spinner">Keine Button-Aktivitäten vorhanden</div>';
                return;
            }
            
            container.innerHTML = logs.map(log => {
                const timestamp = new Date(log.timestamp).toLocaleString('de-DE');
                const statusClass = log.execution_success ? 'success' : 'error';
                
                return `
                    <div class="log-entry">
                        <div class="log-timestamp">${timestamp}</div>
                        <div class="log-details">
                            GPIO ${log.gpio_pin} (${log.button_name || 'Unbenannt'}) → 
                            Gruppe ${log.group_id} (${log.action_type}) 
                            [${log.press_type} press]
                        </div>
                        <div class="log-status ${statusClass}">
                            ${log.execution_success ? 'Erfolg' : 'Fehler'}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function editButtonConfiguration(configId) {
            // For now, show a simple alert - could be enhanced with a modal
            showNotification('🔧 Edit-Funktion kommt bald...', 'info');
        }

        function clearButtonLogs() {
            if (!confirm('Sind Sie sicher, dass Sie alle Button-Logs löschen möchten?')) {
                return;
            }
            
            showNotification('🚧 Clear-Logs-Funktion wird implementiert...', 'info');
        }
    </script>
    <script>
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("/static/service-worker.js")
            .then(reg => console.log("Service Worker registered"))
            .catch(err => console.log("Service Worker registration failed"));
    }
    </script>
    
    <!-- Footer -->
    <footer style="text-align: center; padding: 20px; margin-top: 40px; color: rgba(255, 255, 255, 0.6); font-size: 14px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        Made with ❤️ by Martin Pfeffer
    </footer>
</body>
</html>
